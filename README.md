# Certificate
The certificate cannot represent everything about me.  But I want to prove part of myself as a certificate.

# 1과목(소프트웨어 설계)

- **시스템의 구성요소로 볼 수 없는 것은?**
    
    정답: 3번
    
    시스템 구성요소
    
    입력 (Input) : 처리 방법, 처리할 데이터, 조건을 시스템에 투입하는 것
    
    처리 (Process) : 입력된 데이터를 처리 방법과 조건에 따라 처리하는 것
    
    출력 (Output) : 처리된 결과를 시스템에서 산출하는 것
    
    제어 (Control) : 자료를 입력하여 출력될 때까지의 처리 과정이 올바르게 진행되는지 감독하는 것
    
    피드백 (Feedback) : 출력된 결과가 예정된 목표를 만족시키지 못할 경우 목표 달성을 위해 반복 처리하는 것
    
    Maintenance는 유지보수로서, 시스템 구성요소에는 포함되지 않음.
    

1. Process
2. FeedBack
3. Maintenance
4. Control

---

- **유스케이스(Usecase)에 대한 설명 중 옳은 것은?**
    
    정답: 2번
    
    유스케이스는 시스템이 액터에게 제공해야 하는 기능으로, 시스템의 요구사항이자 기능을 의미
    
    유스케이스 다이어그램은 사용자의 요구를 추출하고 분석하기 위해 주요 사용
    
    여기서 액터는 시스템 외부에서 시스템과 상호작용하는 사람 혹은 시스템을 말함
    
    사용자 액터: 기능을 요구하는 대상이나 시스템의 수행결과를 통보받는 사용자 혹은 기능을 사용하게 될 대상으로
    
    시스템이 제공해야하는 기능인 유스케이스의 권한을 가지는 대상, 역할
    
    시스템 액터: 사용자 액터가 사용한 유스케이스를 처리해주는 외부 시스템, 시스템의 기능 수행을 위해서 연동이 되는 또 다른 시스템 액터를 의미
    
    [해설작성자 : 컴린이]
    
    액터?
    
    - 시스템과 상호작용을 하는 모든 외부 요소로, 사람이나 외부 시스템을 의미
    - 주액터(사용자 액터)
    - 부액터(시스템 액터)
    
    1번 개발자의 요구X   사용자의 요구O
    
    3번 부액터(시스템 액터) 설명임
    
    4번 일방적X  양방향O
    

1. 유스케이스 다이어그램은 개발자의 요구를 추출하고 분석하기 위해 주로 사용한다
2. 엑터는 대상 시스템과 상호 작용하는 다른 사람이나 시스템에 의한 역할이다.
3. 사용자 액터는 본 시스템과 데이터를 주고받는 연동 시스템을 의미한다.
4. 연동의 개념은 일방적으로 데이터를 파일이나 정해진 형식으로 넘겨주는 것을 의미한다.

---

- **요구사항 개발 프로세스의 순서로 옳은 것은?**
    
    정답: 1번
    
    요구사항을 “도출"해야 “분석"하고, 분석해야 자세히 쓸 수 있고(명세), 명세를 검토해야 한다.
    
    **도분명확**
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cecd3f71-8347-4e1d-ab70-583fdf766169/Untitled.png)

1. ㄱ-ㄴ-ㄷ-ㄹ
2. ㄱ-ㄷ-ㄴ-ㄹ
3. ㄱ-ㄹ-ㄴ-ㄷ
4. ㄱ-ㄴ-ㄹ-ㄷ

---

- **GoF (Gangs of Four) 디자인 패턴에 대한 설명으로 틀린 것은?**
    
    정답: 3번
    
    bridge pattern은 구현부에서 추상층을 분리하여 각자 독립적으로 확장이 가능하게 하는 패턴이다
    
    [해설작성자 : comcbt.com 이용자]
    
    3은 Adapter pattern의 설명
    

1. factory method pattern은 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식이다.
2. prototype pattern은 prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.
3. bridge pattern은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.
4. mediator pattern은 객체간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다.

---

- **CASE(Computer-Aided Software Engineering)의 원천 기술이 아닌 것은?**
    
    정답: 4번
    
    Case의 원천 기술은 구조적 기법, 프로토타이핑 기술, 자동프로그래밍 기술, 정보 저장소 기술, 분산 처리 기술이 있다 (구프자정분)
    

1. 구조적 기법
2. 프로토타이핑 기술
3. 정보 저장소 기술
4. 일괄처리 기술

---

- **UML 다이어그램이 아닌 것은?**
    
    정답 :2번
    
    업무의 흐름을 모델링하거나 객체의 생명 주기를 표현하는 Activity 다이어그램
    
    객체 간의 메시지 전달을 시간적 흐름에서 분석하는 Sequence 다이어그램
    
    기업 환경의 구성과 컴포넌트들 간의 관계를 그린 Deployment 다이어그램
    
    객체와 객체가 주고받는 메시지 중심의 작성 동적 다이어그램인 Collaboration 다이어그램
    
    소프트웨어 구조가 그리는 Component 다이어그램
    
    시스템의 구조적인 모습을 그리는 Class 다이어그램
    

1. 액티비티 다이어그램(Activity diagram)
2. 절차 다이어그램(Procedural diagram)
3. 클래스 다이어그램(Class diagram)
4. 시퀀스 다이어그램(Sequence diagram)

---

- **UML 모델에서 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계로 옳은 것은?**
    
    정답: 2번
    
    Dependency(의존) : 한 사물의 명세서가 바뀌면 그것을 사용하는 다른 사물에게 영향을 끼치는 것을 말합니다 (Cascade 생각하셈)
    
    Realization(실체화) : 한 객체가 다른 객체에 의해 오퍼레이션을 수행하도록 지정
    
    Generalization(일반화) : 일반화된 사물과 좀 더 특수화된 사물 사이의 관계를 말합니다.('is-a')관계
    
    Association(연관) : 두 사물간의 구조적 관계로, 어느 한 사물 객체가 다른 사물 객체와 연결되어 있음을 말함 ('has-a')관계라고도 합니다
    
    [해설작성자 : 정규직되고파]
    

1. Dependency
2. Realization
3. Generalization
4. Association

---

- 애자일 개발 방법론이 아닌 것은?
    
    정답: 4번
    
    애자일 개발 방법론
    
    익스트림 프로그래밍(XP , Extreme Programming)
    
    스크럼크리스털 패밀리
    
    기능 주도 개발(FDD , Feature-Driven Development)
    
    적응형 소프트웨어 개발 (ASD , Adaptive Software Development(
    
    익스트림 모델링
    
    하둡(Hadoop)
    
    분산 환경에서 빅 데이터를 저장하고 처리할 수 있는 자바 기반의 오픈 소스 프레임 워크.
    

1. 스크럼(Scrum)
2. 익스트림 프로그래밍(XP, eXtreme Programming)
3. 기능 주도 개발(FOD, Feature Driven Development)
4. 하둡(Hadoop)

---

- GoF(Gangs of Four)디자인 패턴 중 생성패턴으로 옳은 것은?
    
    정답: 1번
    
    생성패턴: 객체를 생성하는 것에 대한 패턴
    
    추상팩토리 패턴, 빌더 패턴, 팩토리 메소드 패턴, 프로토타입 패턴, 싱글톤 패턴
    
    구조 패턴: 구조를 통해 확장성을 꾀하는 패턴
    
    어댑터 패턴, 브릿지 패턴, 컴포지트 패턴, 데코레이터 패턴, 퍼사드 패턴, 플라이웨잇 패턴, 프록시 패턴
    
    행위 패턴: 행위의 변경, 수정 등을 위한 패턴
    
    역할 사슬 패턴, 커맨드 패턴, 인터프리터 패턴, 이터레이터 패턴, 미디에이터 패턴, 메멘토 패턴, 옵저버 패턴, 스테이트 패턴, 스트래티지 패턴, 템플릿 메소드 패턴, 비지터 패턴
    
    [해설작성자 : 컴린이]
    
    1. singleton pattern(단일체): 한 클래스에 한 객체만 존재하도록 제한한다(생성패턴)
    
    2. adapter pattern(적응자): 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다(구조패턴)
    
    3. decorator pattern(장식자): 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있다(구조패턴)
    
    4. state pattern(상태): 동일한 동작을 객체의 상태에 따라 다르게 처리해야 할 때 사용하는 디자인 패턴(행위패턴)
    

1. singleton pattern
2. dapter pattern
3. decorator pattern
4. state pattern

---

- **소프트웨어 설계에서 사용되는 대표적인 추상화(Abstraction) 기법이 아닌 것은?**
    
    정답: 4
    
    <문제 해설>
    
    제어 추상화: 제어의 정확한 메커니즘을 정의하지 않고 원하는 효과를 정하는데 이용하는 방법
    
    기능 추상화: 입력 자료를 출력자료로 변환하는 과정을 추상화하는 방법
    
    자료 추상화: 자료와 자료에 적용될 수 있는 기능을 함께 정의함으로써 자료 객체를 구성하는 방법
    

1. 자료 추상화
2. 제어 추상화
3. 과정 추상화
4. 강도 추상화

---

- **요구 분석(Requirement Analysis)에 대한 설명으로 틀린 것은?**
    
    **정답: 4**
    
    <문제 해설>
    
    기능적 요구사항- 시스템이 수행해야 하는 행위들을 구체화 한 것- 시스템에서 제공해야 할 기능을 정의한 것- 입력기능, 출력기능, 데이터베이스 기능, 통신 기능 등비기능적 요구사항- 시스템이 가져야 하는 기능 이외의 요구사항- 시스템의 전체적인 품질이나 고려해야 하는 제약사항 등- 사용 용이성, 효율성, 신뢰성, 이식성, 유연성, 확장성 등- 성능적인 면: 응답 속도, 자원 사용량 등- 보안 측면: 침입 대응, 침입 탐지, 사용자 인증, 권한 부여 등
    

1. 요구 분석은 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대해 이해하는 단계라 할 수 있다.
2. 요구 추출(Requirement Elicitation)은 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계이다.
3. 도메인 분석(Domain Analysis)은 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 하게 된다.
4. 기능적(Functional) 요구에서 시스템 구축에대한 성능, 보안, 품질, 안정 등에 대한 요구사항을 도출한다.

---

- **클래스 다이어그램의 요소로 다음 설명에 해당하는 용어는?**
    
    정답: 2
    
    작동, 동작 = 오퍼레이션
    

> 클래스의 동작을 의미한다
> 

> 클래스에 속하는 객채에 대하여 적용될 메서들르 정의한 것이다
> 

> UML에서는 동작에 대한 인터페이스를 지칭한다고 볼 수 있다.
> 
1. Instance
2. Operation
3. Item
4. Hiding

---

- **요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서 사용되는 다이어그램(Diagram)이 아닌 것은?**
    
    정답: 4
    
    avl 트리는 이진 트리의 높낮이가 불규칙해지는 것을 보완하여
    
    일정하게 처리하기 위한 이진트리 모형이다.
    

1. Data Flow Diagram
2. UML Diagram
3. E-R Diagram
4. AVL Diagram

---

- **GoF(Gang of Four) 디자인 패턴과 관련한 설명으로 틀린 것은?**
    
    정답: 2번
    
    GoF(Gang of Four) 패턴: 에리히 감마(Erich Gamma), 리처드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)가 같이 고안한 디자인 패턴
    
    23가지 디자인 패턴을 3가지 분류로 정리한 디자인 패턴
    
    - 생성 패턴: Abstract Factory, Builder, Factory Method, Prototype, Singleton
    - 구조 패턴: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
    - 행위 패턴: Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategty, Template Method, Visitor
    
    보기 2번의 Strategy 패턴은 행위 패턴에 해당
    
    [해설작성자 : 이거까지알아야해?]
    
    디자인 패턴 = 생구행을떠올리자
    
    생(성) - 추빌팩프싱      *추 : Abstract Factory(추상팩토리)
    
    구(조) - 어브컴데퍼플프
    
    행(위) - 위에 2개 해당안하면 행위패턴임
    

1. 디자인 패턴을 목적(Purpose)으로 분류할 때 생성, 구조, 행위로 분류할 수 있다.
2. Strategy 패턴은 대표적인 구조 패턴으로 인스턴스를 복제하여 사용하는 구조를 말한다.
3. 행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.
4. Singleton 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다.

---

- **럼바우(Rumbaugh)의 객체지향 분석 기법 중 자료 흐름도(DFD)를 주로 이용하는 것은?**
    
    정답: 1번
    
    럼바우 분석기법
    
    객,동,기
    
    객체모델링 = 객체 다이어그램
    
    동적모델링 = 상태 다이어그램
    
    기능 모델링 = 자료흐름도
    

1. 기능 모델링
2. 동적 모델링
3. 객체 모델링
4. 정적 모델링

---

- **객체지향 분석 기법과 관련한 설명으로 틀린것은?**
    
    정답: 2번
    
    2번은 순차적인 하향식 처리방식이기 때문에 절차지향 분석 기법
    

1. 동적 모델링 기법이 사용될 수 있다.
2. 기능 중심으로 시스템을 파악하며 순차적인처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.
3. 데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업이라 할 수 있다.
4. 코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다.

---

- **대표적으로 DOS 및 Unix 등의 운영체제에서조작을 위해 사용하던 것으로, 정해진 명령문자열을 입력하여 시스템을 조작하는 사용자인터페이스(User Interface)는?**
    
    정답: 2번
    
    GUI(Graphical User Interface) : 사용자가 편리하게 사용할 수 있도록 입출력 등의 기능을 알기 쉬운 아이콘 따위의 그래픽으로 나타낸 것
    
    CLI(Command Line Interface) : 텍스트 터미널을 통해 사용자와 컴퓨터가 명령문자열로 상호 작용하는 방식
    

1. GUI(Graphical User Interface)
2. CLI(Command Line Interface)
3. CUI(Cell User Interface)
4. MUI(Mobile User Interface)

---

- **소프트웨어 아키텍처와 관련한 설명으로 틀린것은?**
    
    정답: 1번
    
    파이프 필터 아키텍처에서 데이터는 파이프를 통해 단방향으로 흐르고, 필터 이동시 오버헤드가 발생될 수 있음.
    
    (파이프 모양의 컵에 물을 계속 따르면 물이 넘쳐 흐르는것 처럼...)
    

1. 파이프 필터 아키텍처에서 데이터는 파이프를 통해 양방향으로 흐르며, 필터 이동 시 오버헤드가 발생하지 않는다.
2. 외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조로 볼수 있다.
3. 데이터 중심 아키텍처는 공유 데이터저장소를 통해 접근자 간의 통신이 이루어지므로 각 접근자의 수정과 확장이 용이하다.
4. 이해 관계자들의 품질 요구사항을 반영하여품질 속성을 결정한다.

---

# 2과목(소프트웨어 개발)

- **힙 정렬(Heap Sort)에 대한 설명으로 틀린것은?**
    
    정답: 4번
    
    최악 : O(nlog n)
    
    [해설작성자 : 꿀유자]
    
    힙 정렬(Heap Sort) : 평균과 최악 모두 시간 복잡도는 O(nlog2n)
    

1. 정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키 값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다
2. 평균 수행 시간은 O(nlog2n)이다.
3. 완전 이진트리(complete binary tree)로 입력자료의 레코드를 구성한다.
4. 최악의 수행 시간은 O(2n4)이다.

---

- **소프트웨어 테스트와 관련한 설명으로 틀린것은?**
    
    정답: 4번
    
    화이트 박스 테스트 : 내부 구조와 동작을 검사하는 테스트 방식, 소프트웨어의 내부 소스를 테스트
    
    블랙 박스 테스트 : 내부 구조나 작동 원리를 모르는 상태에서 입력에 따른 출력 결과를 테스트
    
    4. 화이트 박스 테스트에서 기본 경로는 싸이클을 최대 한번만 지나야한다.
    
    [해설작성자 : 해군본부 정체단 674기 수뱅]
    
    화이트박스테스트는 내부의 논리적인 모든 경로를 테스트해 테스트 케이스를 설계함.
    

1. 화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 있다.
2. 블랙박스 테스트는 프로그램의 구조를 고려하지 않는다
3. 테스트 케이스에는 일반적으로 시험 조건, 테스트 데이터, 예상 결과가 포함되어야 한다.
4. 화이트박스 테스트에서 기본 경로(BasisPath)란 흐름 그래프의 시작 노드에서 종료노드까지의 서로 독립된 경로로 싸이클을 허용하지 않는 경로를 말한다.

---

- **디지털 저작권 관리(DRM) 구성 요소가 아닌 것은?**
    
    정답: 1번
    
    [저작권 관리구성요소]
    
    - 콘텐츠 분배자: 암호화된 콘텐츠를 유통하는곳/사람
    - 패키저: 콘텐츠를 메타데이터와 함께 배포가능한 형태로 묶어 암호화
    - 클리어링 하우스: 키 관리 및 라이센스 발급 관리
    - DRM 컨트롤러: 배포된 콘텐츠의 이용권한을 통제
    
    [해설작성자 : 코로그]
    
    클리어링 하우스(Clearing House) : 디지털 저작권 라이선스의 중개 및 발급을 수행하는 곳, 디지털 저작물의 이용 내역을 근거로 저작권료의 정산 및 분배가 수행된다. Dataware house 아님
    

1. Dataware house
2. DRM Controller
3. Packager
4. Contents Distributor

---

- **다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 Pass 2의 결과는?**
    
    정답: 4번
    
    Pass 1  9 6 7 3 5  →  6 9 7 3 5  →  6 7 9 3 5  →  6 7 3 9 5  →  6 7 3 5 9
    
    Pass 2  6 7 3 5 9  →  6 3 7 5 9  →  6 3 5 7 9
    
    [해설작성자 : comcbt.com 이용자]
    
    버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
    
    [해설작성자 : 쀼쮸]
    

              9, 6, 7, 3, 5

1. 3, 5, 6, 7, 9
2. 6, 7, 3, 5, 9
3. 3, 5, 9, 6, 7
4. 6, 3, 5, 7, 9

---

- **정렬된 N개의 데이터를 처리하는 데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?**
    
    정답: 1번
    
    O(N*log2N) : 선형 로그형 복잡도 : 로그,변수에 비례 ⇒ 퀵정렬,병합정렬
    
    O(N2) : 제곱형 : 제곱에 비례 ⇒ 버블정렬, 삽입정렬, 선택정렬
    
    정렬된 데이터의 경우, 버블정렬과 삽입정렬은 O(N) 이 될 수 있음
    

1. 합병정렬
2. 버블정렬
3. 선택정렬
4. 삽입정렬

---

- 인터페이스 구현 검증 도구가 아닌 것은?
    
    정답: 1번
    
    인터페이스 구현 검증 도구는 xUnit, STAF, Fitnesse, NTAF, Selenium, watir 등이 있습니다.
    
    Foxbase는 프로그래밍 언어입니다.
    

1. Foxbase
2. STAF
3. watir
4. xUnit

---

- 테스트와 디버그의 목적으로 옳은 것은?
    
    정답: 1번
    
    Coding
    
    → Testing
    
    → Error 발생 (== Bug 발견)
    
    → Error 수정 (== Debugging)
    
    → Retesting
    

1. 테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다.
2. 테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 작업이다.
3. 둘 다 소프트웨어의 오류를 찾는 작업으로 오류 수정은 하지 않는다.
4. 둘 다 소프트웨어 오류의 발견, 수정과 무관하다.

---

- **다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 PASS 3의 결과는?**
    
    버블 정렬(Bubble Sort)
    
    : 인접한 데이터를 비교하면서 데이터의 위치를 바꾸어 정렬하는 방법
    
    한번의 Pass 내에서 다수의 교체 발생
    
    Pass 1: 6 7 3 5 9
    
    Pass 2: 6 3 5 7 9
    
    Pass 3: 3 5 6 7 9
    

> 9, 6, 7, 3, 5
> 
1. 6, 3, 5, 7, 9
2. 3, 5, 6, 7, 9
3. 6, 7, 3, 5, 9
4. 3, 5, 9, 6, 7

---

- **다음 설명에 부합하는 용어로 옳은 것은?**
    
    정답: 3번
    
    규모가 큰 것을 여러 개로 나눈 조각,
    
    소프트웨어 구조를 이루는 기본적인 단위
    
    모듈이 되기 위한 특징
    
    - 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위.
    - 유니크한 이름을 가짐
    - 모듈에서 또 다른 모듈을 호출 가능
    - 다른 프로그램에서도 모듈을 호출할 수 있다.
    
    데이터
    
    관찰하고 측정해서 얻은 Value
    
    저장소
    
    데이터를 논리적 구조로 조직화, 혹은 물리적 공간에 구축한것
    

- 소프트웨어 구조를 이루며, 다른 것들과 구별될 수 있는 독립적인 기을 갖는 단위이다.
- 하나 또는 몇 개의 논리적인 기능을 수행하기 위한 명령어들의 집합이라고도 할 수 있다.
- 서로 모여 하나의 완전한 프로그램으로 만들어 질 수 있다.

1. 통합 프로그램
2. 저장소
3. 모듈
4. 데이터

---

- **테스트 드라이버(Test Driver)에 대한 설명으로 틀린 것은?**
    
    정답: 4번
    
    <문제 해설>1, 2, 3번은 테스트 드라이버에 대한 설명4번은 테스트 스텁에 대한 설명테스트 드라이버(Driver)- 테스트 대상 하위 모듈을 호출하고, 파라미터 전달, 모듈 테스트 수행 후의 결과 도출- 상향식 테스트에 사용됨테스트 스텁(Stub)- 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구- 하향식 테스트에 사용됨
    

1. 시험대상 모듈을 호출하는 간이 소프트웨어이다.
2. 필요에 따라 매개 변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있다.
3. 상향식 통합 테스트에서 사용된다.
4. 테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다.

---

- **다음 중 선형 구조로만 묶인 것은?**
    
    정답: 2번
    
    선형구조: 리스트, 스택, 큐, 덱
    
    비선형구조: 트리, 그래프
    
    파일구조: 순차파일, 색인파일, 직접파일
    

1. 스택, 트리
2. 큐, 데크
3. 큐, 그래프
4. 리스트, 그래프

---

- **다음 중 스택을 이용한 연산과 거리가 먼 것은?**
    
    정답: 1번
    
    선택 정렬은 큐를 이용해서 정렬한다.
    

1. 선택정렬
2. 재귀 호출
3. 후위표현(Post-fix expression)의 연산
4. 깊이우선탐색

---

- **제품 소프트웨어의 사용자 매뉴얼 작성절차로 (가)~(다)와 [보기]의 기호를 바르게 연결한 것은?**
    
    정답: 2번
    
    사용자 매뉴얼 준비 절차
    
    작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토
    
    설치와 사용에 필요한 제반 절차 및 환경 등 전체 내용을 포함하는 매뉴얼을 작성해야 합니다.
    

작성 지침 정의 → 가 → 나 → 다 → 사용설명서

- ㄱ 사용 설명서 검토
- ㄴ 구성 요소별 내용 작성
- ㄷ 사용 설명서 구성 요소 정의

1. 가-ㄱ 나-ㄴ 다-ㄷ
2. 가-ㄷ 나-ㄴ 다-ㄱ
3. 가-ㄱ 나-ㄷ 다-ㄴ
4. 가-ㄷ 나-ㄱ 다-ㄴ

---

- **순서가 A, B, C, D로 정해진 입력 자료를 스택에 입력한 후 출력한 결과로 불가능한 것은?**
    
    정답: 4번
    
    1. A push - B push - C push - D push - D pop - C pop - B pop - A pop
    
    2. A push - B push - B pop - C push - C pop - D push - D pop - A pop
    
    3. A push - B push - C push - C pop - B pop - A pop - D push - D pop
    
    4. 스택의 환경에서 불가능한 출력 결과물
    

1. D, C, B, A
2. B, C, D, A
3. C, B, A, D
4. D, B, C, A

---

- **소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?**
    
    정답: 1번
    
    이식성(Portability): 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 능력
    
    2. 효율성(Efficiency): 최소의 작업으로 요구되는 기능을 수행하는 정도
    
    3. 사용 용이성(Usability): 소프트웨어를 쉽게 사용할 수 있는 정도
    
    4. 정확성(Correctness): 사용자의 요구사항을 충족시키는 정도
    

1. Portability
2. Efficiency
3. Usability
4. Correctness

---

## 4과목

- **다음 트리에 대한 중위 순회 운행 결과는?**
    
    정답: 4번
    
    전위: 중앙 노드 먼저 방문
    
    중위: 왼쪽 노드 방문 후 중앙 노드 방문
    
    후위: 하위 트리 노드 모드 방문 중앙 노드 방문
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1898bb8-b2e2-4753-9159-7841f3d11790/Untitled.png)

1. ABDCEF
2. ABCDEF
3. DBECFA
4. DBAECF

---

- 관계 데이터베이스에 있어서 관계 대수 연산이 아닌 것은?
    
    정답: 3번
    
    관계 대수 연산에는
    
    1. Select
    
    2. Project
    
    3. Join
    
    4. Division 이 있디.
    
    [해설작성자 : comcbt.com 이용자]
    
    관계대수 연산에는
    
    1. 일반 집합 연산자
    
    합집합
    
    교집합
    
    차집합
    
    카티션 프로덕트
    
    2. 순수 관계 연산자
    
    셀렉트
    
    프로젝트
    
    조인
    
    디비전
    

1. 디비전
2. 프로젝트
3. 조인
4. 포크

---

- **로킹 단위(Locking Granularity)에 대한 설명으로 옳은 것은?**
    
    
    정답: 1번
    
    <문제 해설>로킹 단위가 큼 -> 로크의 수가 적어짐 -> 병행성 수준 낮아짐, 병행 제어 기법 간단해짐로킹 단위가 작음 -> 로크의 수가 많아짐[해설작성자 : 싹싹이]로킹 (병행제어 기법의 종류 중 하나)-직렬화 기법-데이터베이스, 파일, 레코드 등은 로킹단위가 될 수 있음.-로킹 단위가 작아지면, 데이터 베이스 공유도 증가.-로킹 단위가 작아지면, 로킹 오버헤드 증가.-로킹 단위가 작아지면, 로크의 수 증가.-로킹 단위가 작아지면, 병행성 수준이 높아짐.-한꺼번에 로킹할 수 있는 객체의 크기를 로킹단위 라고 함.
    

1. 로킹 단위가 크면 병행성 수준이 낮아진다
2. 로킹 단위가 크면 병행 제어 기법이 복잡해진다.
3. 로킹 단위가 적으면 로크(lock)의 수가 적어진다.
4. 로킹은 파일 단위로 이루어지며, 레코드와 필드는 로킹 단위가 될 수 없다.

---

- **이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속(JD : Join Dependency) 제거해야 만족하는 정규형은?**
    
    정답: 3번
    
    1. 제 1 정규형 : 릴레이션에 속한 모든 속성의 도메인이 더는 분해되지 않는 원자값으로만 구성되어 있음
    
    2. 제 2 정규형 : 제 1 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속 되어야 함
    
    3. 제 3 정규형 : 제 2 정규형에 속하고 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않을 시 속함
    
    4. 제 4 정규형 : 보이스/코드 정규형을 만족하며 함수 종속이 아닌 다치 종속 제거시 만족
    
    5. 제 5 정규형 : 제 4 정규형을 만족하며 후보키를 통하지 않는 조인 종속 제거해야 만족
    

1. 제3정규형
2. 제4정규형
3. 제5정규형
4. 제6정규형

---

- **어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 경우 애트리뷰트 X의 값 각각에 대해 시간에 관계없이 항상 애트리뷰트 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속이라고 한다. 이 함수 종속의 표기로 옳은 것은?**
    
    정답: 3번
    
    <문제 해설>
    
    함수적 종속이란 어떤 릴레이션 R이 있을때 X와 Y를 각각 속성의 부분집합이라고 가정해봅니다. 여기서 X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, Y는 X에 함수적 종속이라고 합니다. 이 경우 X를 결정자, Y를 종속자라고 합니다.
    

1. Y → X
2. Y ⊂ X
3. X → Y
4. X ⊂ Y

---

- **오류 제어에 사용되는 자동반복 요청방식(ARQ)이 아닌 것은?**
    
    정답: 4번
    
    - Stop-and-Wait ARQ(정지-대기 ARQ): 송신 측이 하나의 블록을 전송한 후 수신 측에서 에러의 발생을 점검한 다음, 에러 발생 유무 신호를 보내올 때까지 기다리는 방식
    - Go-Back-N ARQ: 여러 블록을 연속적으로 전송하고, 수신 측에서 부정 응답(NAK)을 보내오면 송신 측이 오류가 발생한 블록부터 모두 재 전송
    - Selective-Reapeat ARQ(선택적 재전송 ARQ): 여러 블록을 연속적으로 전송하고, 수신측에서 부정 응답(NAK)을 보내오면 송신 측이 오류가 발생한 블록만을 재전송
    - Adaptive ARQ(적응적 ARQ): 전송 효율을 최대로 하기 위해서 데이터 블록의 길이를 채널의 상태에 따라 동적으로 변경하는 방식

1. Stop-and-wait ARQ
2. Go-back-N ARQ
3. Select-Repeat ARQ
4. Non-Acknowledge ARQ

---

- **사용자가 요청한 디스크 입·출력 내용이 다음과 같은 순서로 큐에 들어 있을 때 SSTF 스케쥴링을 사용한 경우의 처리 순서는? (단, 현재 헤드 위치는 53 이고, 제일 안쪽이 1번, 바깥쪽이 200번 트랙이다.)**
    
    정답: 1번
    
    <문제 해설>SSTF : shortest seek time first현재 헤드위치에서 가장 가까운 것부터..현재 헤드위치가 53이므로 65가 가장 가깝고( 차이 12) 다른것도 동일한 방법으로 해결.[해설작성자 : 귀살대]가장 가까운 것 => 가장 이동 거리가 짧은 것 => 현재 트랙과 남아있는 트랙 중 차이가 적은 것  53 - 65 - 67 - 37 - 14 - 98 - 122 - 124 - 183   12   2    30   23   84   24    2     59
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a08094f-72a9-4f8b-be4b-3bd381f7845c/Untitled.png)

1. 53-65-67-37-14-98-122-124-183
2. 53-98-183-37-122-14-124-65-67
3. 53-37-14-65-67-98-122-124-183
4. 53-67-65-124-14-122-37-183-98

---

- **192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 4개의 Subnet으로 나누고 IP Subnet-zero를 적용했다. 이 때 Subnetting 된 네트워크 중 4번째 네트워크의 4번째 사용가능한 IP는 무엇인가?**
    
    정답: 3번
    
    CIDR 표기법으로 ipv4 32비트중 앞 24비트가 네트워크ip, 뒤 8비트가 호스트ip가 됩니다.
    
    여기서 4개의 서브넷으로 나누려면 호스트ip의 앞쪽 비트를 가능한 적게 4개까지 나누어줘야 하는데요
    
    2진수에서 4개로 나누려면 2비트를 사용해야 하므로
    
    192.168.1.(00)000000 (0)
    
    192.168.1.(01)000000 (64)
    
    192.168.1.(10)000000 (128)
    
    192.168.1.(11)000000 (192)
    
    로 나눌 수 있습니다.
    
    여기서 IP subnet-zero를 적용했다는것은
    
    호스트ip가 전부 0인 192.168.1.0 도 사용하겠단것을 의미 합니다.
    
    즉 4번째 네트워크는 192.168.1.192가 되겠죠?
    
    단 각 서브넷에서 호스트ip가 전부 0인 주소와 전부 1인 주소는 다른 용도로 이미 예약이 되어있습니다.(0은 네트워크 자체의 주소, 1은 브로드캐스팅 주소)
    
    즉 여기서 4번째 사용가능한 ip는
    
    193,194,195,196←이게 되는거죠
    

1. 192.168.1.192
2. 192.168.1.195
3. 192.168.1.196
4. 192.168.1.198

---

- C Class에 속하는 IP Address는?
    
    정답: 1번
    
    <문제 해설>
    
    A class에 속하는 ip 주소 범위: 0.0.0.0 ~ 127.255.255.255
    
    B class에 속하는 ip 주소 범위: 128.0.0.0 ~ 191.255.255.255
    
    C class에 속하는 ip 주소 범위: 192.0.0.0 ~ 223.255.255.255
    
    D class와 E class는 각각 멀티캐스트용, 연구용으로 사용됩니다.
    
    D class ip 주소 범위: 224.0.0.0 ~ 239.255.255.255
    
    E class ip 주소 범위: 240.0.0.0 ~ 255.255.255.255
    

1. 200.168.30.1
2. 10.3.2.1 4
3. 225.2.4.1
4. 172.16.98.3

---

- **다음 JAVA 프로그램이 실행되었을 때의 결과를 쓰시오.**
    
    정답: 3번
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/300ff53e-293a-4446-9015-90eb46f00068/Untitled.png)

1. 13
2. 21
3. 34
4. 55

---

## 5과목: 정보시스템 구축관리

- 다음 내용이 설명하는 접근 제어 모델은?
    
    정답: 3번
    
    BLP 기밀성 모델: 정보의 불법적인 파괴나 변조보다는 불법적인 비밀 유출 방지에 중점 - 기밀성 강조
    
    Clark-Wilson 무결성 모델: 비밀 노출 방지보다 자료의 변조 방지가 더 중요함(금융, 회계관련 데이터, 기업 재무재표 등)
    
    Chinese Wall: 충돌을 야기시키는 어떠한 정보의 흐름도 없어야 한다. 이익의 충돌 금지, 최근 일을 한 적 있는 파트너는 동일 영역에 있는 다른 회사 자료에 접근해서는 안된다.
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d6baf7c5-3df8-4ec4-bc2b-b5723776d93c/Untitled.png)

1. Clark-wilson Integrity Model
2. PDCA Model
3. Bell-lapadual Model
4. Chinese Wall Model

---

- **하둡(Hadoop)과 관계형 데이터베이스간에 데이터를 전송할 수 있도록 설계된 도구는?**
    
    정답: 3번
    
    스쿱: 커넥터를 사용하여 관계형 디비시스템(RDBMS)에서 HDFS로 데이터를 수집하는 빅데이터 기술
    

1. Apnic
2. Topology
3. Sqoop
4. SDB

---

- **라우팅 프로토콜인 OSPF(Open Shortest Path First)에 대한 설명으로 옳지 않은 것은?**
    
    정답: 2번
    
    거리 벡터 라우팅 프로토콜은 RIP
    
    OSPF 는 '링크 상태 알고리즘'을 사용합니다.
    

1. 네트워크 변화에 신속하게 대처할 수 있다.
2. 거리 벡터 라우팅 프로토콜이라고 한다.
3. 멀티캐스팅을 지웑한다.
4. 최단 경로 탐색에 Dijkstra 알고리즘을 사용한다

---

- **소프트웨어 비용 추정 모형(estimation models)이 아닌 것은?**
    
    정답: 4번
    
    - COCOMO : 시스템의 비용을 산정하기 위해 시스템을 구성하고 있는 모듈과 서브 시스템의 비용 합계를 계산하는 방식
    - Putnam : 소프트웨어 개발 주기의 간 단계별로 요구할 인력의 분포를 가정하는 모형
    - Function-Point(FP) : 요구 기능을 증가시키는 인자별로 가중치를 부여하여 기능의 점수를 계산하여 비용을 산정하는 방식
    - PERT : 계획 평가 및 재검토 기술, 프로젝트 관리를 분석하거나 주어진 완성 프로젝트를 포함한 일을 묘사하는데 쓰이는 모델

1. COCOMO
2. Putnam
3. Function-Poinmt
4. PERT

---

- **코드의 기입 과정에서 원래 '12536‘으로 기입되어야 하는데 ’12936‘으로 표기되었을 경우, 어떤 코드 오류에 해당하는가?**
    
    정답: 4번
    
    - 생략 오류(omission error)
    
    입력 시 한 자리를 빼놓고 기록한 경우
    
    (1234 → 123)
    
    - 필사 오류(Transcription error)
    
    입력 시 임의의 한 자리를 잘못 기록한 경우
    
    (1234 → 1235)
    
    - 전위 오류(Transposition error)
    
    입력 시 좌우 자리를 바꾸어 기록한 경우
    
    (1234 → 1243)
    
    - 이중 오류(Double Transposition error)
    
    전위 오류가 두 가지 이상 발생한 경우
    
    (1234 → 2143)
    
    - 추가 오류(Addition error)
    
    입력 시 한 자리 추가로 기록한 경우
    
    (1234 → 12345)
    
    - 임의 오류(Random error)
    
    위의 오류가 두 가지 이상 결합하여 발생한 경우
    
    (1234 → 12367)
    

1. Addtion Error
2. Omission Error
3. Sequence Error
4. Transcription Error

---

- **ISO 12207 표준의 기본 생명주기의 주요 프로세스에 해당하지 않는 것은?**
    
    정답: 4번
    소프트웨어의 생명 주기 동안 필요한 소프트웨어 제품의 획득, 공급, 개발, 운영, 유지보수 등으로 구성된다.
    

1. 획득 프로세스
2. 개발 프로세스
3. 성능평가 프로세스
4. 유지보수 프로세스

---

- **SPICE 모델의 프로세스 수행능력 수준의 단계별 설명이 틀린 것은?**
    
    SPICE 모델은
    
    수준 0부터 수준 5까지 총 6개의 수준이다.
    
    [해설작성자 : 해군본부 정체단 674기 수뱅]
    
    0단계 불안정 (구현 전 or 목적 달성 전)
    
    1단계 수행 (목적이 전반적으로 이뤄짐)
    
    2단계 관리 (작업 산출물 인도)
    
    3단계 확립(공학 원칙을 지킴)
    
    4단계 예측(산출물의 양적 측정이 가능해져, 일관된 수행 가능)
    
    5단계 최적화(지속적으로 업무 목적 만족)
    

1. 수준 8 - 미완성 단계
2. 수준 5- 최적화 단계
3. 수준 4- 예측 단계
4. 수준 3- 확립 단계

---

- 해쉬(Hash)기법에 대한 설명으로 틀린 것은?
    
    정답: 2번
    
    ＜암호화 방식＞
    
    1. 단방향
    
    1-1. 해시
    
    종류 :
    
    SHA, MD5, N-NASH, SNEFRU 등
    
    특징 :
    
    임의의 길이의 입력 데이터나 메시지를  고정 길이의 값이나 키로 변환
    
    암호화, 무결성 검증을 위하여 사용
    
    - --------------
    
    2. 양방향
    
    2-1. 개인키 (암호화, 복호화 시 동일한 개인키를 이용)
    
    종류 :
    
    Stream 방식 (평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화) : LFSR, RC4
    
    Block 방식 (한 번에 하나의 데이터 블록을 암호화) : DES, SEED, AES, ARIA
    
    특징 :
    
    암호화/복호화 속도가 빠르며, 알고리즘이 단순, 공개키 암호 기법보다 파일 크기가 작음
    
    사용자의 증가에 따라 관리해야 할 키의 수가 상대적으로 많아진다
    
    2-2. 공개키 (암호화 시 사용자에게 공개되는 공개키 사용, 복호화 시 비밀키 사용, 비대칭 암호 기법이라고도 함)
    
    종류 :
    
    RSA
    
    특징 :
    
    키의 분배가 용이하고, 관리해야 할 키 수가 적음
    
    암호화/복호화 속도가 느리며 알고리즘이 복잡, 개인키 암호화 방법보다 파일의 크기가 크다.
    

1. 임의의 길의의 입력 데이터를 받아 고정된 길이의 해쉬 값으로 변환한다
2. 주로 공개키 암호화 방식에서 키 생성을 위해 사용한다.
3. 대표적인 해쉬 알고리즘으로 HaVAL, SHA-1 이 있다.
4. 해쉬 함수는 일방향 함수(One-Way funciton)이다.

---

- **IPSec(IP Security)에 대한 설명으로 틀린 것은?**
    
    일방향 암호화는 해시암호화
    
    IPSec : IP계층(3계층)에서 무결성과 인증 보장하는 인증헤더와 기밀성 보장하는 암호화 이용해 양 종단 구간에 보안 서비스 ㅈ공하는 터널링 프로토콜
    
    - IPSec의 세부프로토콜
    - IKE(Internet Key Exchange) : 보안 관련 설정들을 생성, 협상 및 관리하는 프로토콜(udp500번 포트 사용)
    - ESP(Encapsulating Security Payload) : 메세지 인증코드,암호화 이용해 "인증(무결성)","발신지인증","기밀성" 제공 프로토콜
    - AH(Authentication Header) : 기밀성 제외한 메시지 인증코드 이용한 "인증(무결성)","발신지인증"제공 프로토콜

1. 암호화 수행시 일방향 암호화만 지원한다
2. ESP는 발신지 인증, 데이터 무결성, 기밀성 모두를 보장한다
3. 운영 모드는 Tunel 모드와 Transport 모드로 분류된다.
4. AH는 발신지 호스트를 인증하고, IP 패킷의 무결성을 보증한다.

---

- 메모리상에서 프로그램 복귀 주소와 변수 사이에 특정 값을 저장해두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?
    
    정답: 1번
    
    ASLR(Address Space Layout Randomization): 프로그램을 실행할 때마다 스택, 힙, 공유 라이브러리 등을 메모리에 적재할 때 주소를 랜덤화시키는 기법으로써, 공격자로 하여금 메모리 상의 주소를 추측하기 어렵게 한다.
    

1. Stack Guard
2. birdge
3. ASLR
4. FIN

---

- 침입차단 시스템(박화벽) 중 다음과 같은 형태의 구축 유형은?
    
    정답: 3번
    
    스크린 서브넷(Screen Subnet) : 외부 네트워크와 내부 네트워크 사이에 두는 완충적인 통신망
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/455719c5-fa94-4823-b798-026301806a58/Untitled.png)

1. Block Host
2. Tree Host
3. Screened Subnet
4. Ring Homed

---

- **Secure OS의 보안 기능으로 거리가 먼 것은?**
    
    정답: 3번
    

1. 식별 및 인증
2. 임의적 접근 통제
3. 고가용성 지원
4. 강제적 접근 통제

---

- 서버에 열린 포트 정보를 스캐닝해서 보안취약점을 찾는데 사용하는 도구는?
    
    정답: 4번
    
    type : 말 그대로 type
    
    mkdir : 디렉토리 생성하는 명령어
    
    ftp : 응용계층 프로토콜
    

1. type
2. mkdir
3. ftp
4. nmap

---

- 프로세스와 관련된 설명으로 틀린 것은?
    
    정답: 4번
    
    <문제 해설>
    
    - 디스패치 (Dispatch) : 준비 -> 실행할당시간초과 (Time Run Out) : 실행 -> 준비대기 (Block) : 실행 -> 대기깨움 (Wake Up) : 대기 -> 준비PCB : 운영체제가 그 프로세스를 관리하는데 필요한 모든 정보를 유지하는 자료구조 테이블상태, 소유자, 실시간 통계, 스레드, 관련 프로세스 리스트, 자식 프로세스 리스트, 주소공간, 자원, 스택문맥교환 : CPU가 현재 실행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업프로세스의 실행단위를 스레드라고 불린다

1. 프로세스가 준비 상태에서 프로세서가 배당되어 실행 상태로 변화하는 것을 디스패치(Dispatch)라고 한다.
2. 프로세스 제어 블록(PCB, Process Control Block)은 프로세스 식별자, 프로세스 상태 등의 정보로 구성된다.
3. 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 과정을 문맥 교환(Context Switching)이라고 한다.
4. 프로세스는 스레드(Thread)내에서 실행되는 흐름의 단위이며, 스레드와 달리 주소 공간에 실행 스택(Stack)이 없다.

---

- 다음 중 페이지 교체(Page Replacement)알고리즘이 아닌 것은?
    
    정답: 2번
    
    <문제 해설>
    
    페이지 교체 알고리즘의 종류
    
    OPT - Optimal : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
    
    FIFO - First In First Out
    
    LRU - Least Recently Used : 가장 오랫동안 사용되지 않은 페이지 교체
    
    LFU - Least Frequently Used : 참조 횟수가 가장 작은 페이지 교체
    
    MFU - Most Frequently used : 참조 횟수가 가장 많은 페이지 교체
    
    NUR - Not Used Recently : 최근에 사용하지 않은 페이지 교체
    

1. FIFO(First-In-First-Out)
2. LUF(Least Used First)
3. Optimal
4. LRU(Least Recently Used)

---

- **침입탐지 시스템(IDS : Intrusion Detection System)과 관련한 설명으로 틀린 것은?**
    
    정답: 1번
    
    이상탐지(Anomaly Detection) -> Behavior, Statistical Detection로 불리며 평균적 시스템의 상태 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌
    
    오용탐지(Misuse Detection) -> Signature Base나 Knowledge Base로 불리며 미리 입력해둔 공격 패턴이 감지되면 이를 알려줌
    

1. 이상 탐지 기법(Anomaly Detection)은 Signature Base나 Knowledge Base라고도 불리며 이미 발견되고 정립된 공격 패턴을 입력해두었다가 탐지 및 차단한다.
2. HIDS(Host-Based Intrusion Detection)는 운영체제에 설정된 사용자 계정에 따라 어떤 사용자가 어떤 접근을 시도하고 어떤 작업을 했는지에 대한 기록을 남기고 추적한다.
3. NIDS(Network-Based Intrusion Detection System)로는 대표적으로 Snort가 있다.
4. 외부 인터넷에 서비스를 제공하는 서버가 위치하는 네트워크인 DMZ(Demilitarized Zone)에는 IDS가 설치될 수 있다.

---

- **정보 시스템 내에서 어떤 주체가 특정 개체에 접근하려 할 때 양쪽의 보안 레이블(Security Label)에 기초하여 높은 보안 수준을 요구하는 정보(객체)가 낮은 보안 수준의 주체에게 노출되지 않도록 하는 접근 제어 방법은?**
    
    정답: 1번
    
    강제접근통제(Mandatory Access Control), 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
    
    임의접근통제(Discretionary Access Control), 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
    
    사용자계정컨트롤(User Access Control), 프로그램에서 관리자 수준의 권한이 필요한 작업을 수행할 때 사용자에게 알려서 제어할 수 있도록 돕는 기능
    
    자료별 접근통제(Data-Label Access Control > Label-Based Access Control), 개별 행, 열에 대해 쓰기 권한, 읽기 권한을 가졌는지를 명확하게 결정하는 제어 방식
    

1. Mandatory Access Control
2. User Access Control
3. Discretionary Access Control
4. Data-Label Access Control

---

- **국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은?**
    
    정답: 2번
    
    PaaS-TA는 한국지능정보사회진흥원(NIA)가 지원하는 개방형 클라우드 플랫폼입니다.오픈 소스 기반의 Platform as a Service로서 Paas-TA의 "TA"는 "PaaS에 올라 타."의 의미라 합니다. 2016년 4월 버전 1.0 스파게티가 공개되었고, 2021년 2월 5.5 버전 세미나가 출시되어 차세대 전자정부 클라우드에 적용되어 전자정부 서비스의 표준 개발, 운영환경을 제공하는 역할을 수행할 예정이라 합니다.
    

1. N20S
2. PaaS-TA
3. KAWS
4. Metaverse

---

- **물리적 배치와 상관없이 논리적으로 LAN을 구성하여 Broadcast Domain을 구분할 수있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과가 있는 것은?**
    
    정답: 1번
    
    <문제 해설>VLAN(Virtual Local Area Network): 물리적 배치와 상관없이 논리적으로 LAN을 구성Broadcast Domain을 구분할 수 있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과STP(Spanning Tree Protocol): 2개 이상의 스위치가 여러 경로로 연결될 때,무한 루프 현상을 막기 위해서 우선순위 따라 1개의 경로로만 통신하도록 하는 프로토콜ARP(Address Resolution Protocol): 네트워크 상에서 IP 주소를 물리적 네트워크 주소로 대응(bind)시키기 위해 사용되는 프로토콜,(IP를 MAC주소로 바인딩)
    

1. VLAN
2. STP
3. L2AN
4. ARP

---

- **비대칭 암호화 방식으로 소수를 활용한 암호화 알고리즘은?**
    
    정답: 4번
    
    <문제 해설>
    
    개인키 암호화 - 블록 암호화 방식 : DES, SEED, AES, ARIA
    
    개인키 암호화 - 스트림 암호화 방식 : LFSR, RC4
    
    공개키 암호화(비대칭 암호) : RSA
    

1. DES
2. AES
3. SMT
4. RSA

---

- **다음에서 설명하는 IT 스토리지 기술은?**
    
    정답: 1번
    
    두번째 단락의 '컴퓨팅 소프트웨어로(Software) 규정하는(Defined) 데이터 스토리지 체계이며,'
    
    => Software Defined Storage
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a541168b-4b79-4ed8-8157-2837d7622f8f/Untitled.png)

1. Software Defined Storage
2. Distribution Oriented Storage
3. Network Architected Storage
4. Systematic Network Storage

---

- **Cocomo model 중 기관 내부에서 개발된 중소규모의 소프트웨어로 일괄 자료 처리나 과학기술계산용, 비즈니스 자료 처리용으로 5만 라인이하의 소프트웨어를 개발하는 유형은?**
    
    정답: 2번
    
    Organic: 5만 라인 이하의 프로젝트에 적합, 소규모 팀이 개발에 사용
    
    Semidetached: 30만 라인 이하의 프로젝트에 적합, 트랜잭션 처리시스템 등
    
    Embeded: 30만 라인 이상의 프로젝트에 적합, 하드웨어가 포함된 실스간 시스템 등
    

1. Embeded
2. Organic
3. Semi-detached
4. Semi-embeded

---

- **소프트웨어 생명주기 모형 중 Spiral Model에 대한 설명으로 틀린 것은?**
    
    정답: 4번
    
    <문제 해설>
    
    spiral model = 나선형 모형, 점진적 모형1. 대규모2. 개발순서= 계획및 정의 - 위험 분석 - 공학적 개발 - 고객 평가3. sw개발하면서 발생할 수 있는 위험 관리 및 최소화 목적1&2&3의 경우 spiral model의 올바른 특징4. 여러번의 개발 과정을 거쳐 점진적으로 개발과정이 반복되므로 누락되거나 추가된 요구사항 첨가가능. 한번만 수행 x
    

1. 비교적 대규모 시스템에 적합하다
2. 개발 순서는 계획 및 정의, 위험 분석, 공학적 개발, 고객 평가 순으로 진행된다.
3. 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다.
4. 계획, 설계, 개발, 평가의 개발 주기가 한번만 수행된다.

---

- **TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의 메시징 프로토콜로 최근 IoT 환경에서 자주 사용되고 있는 프로토콜은?**
    
    정답: 2번
    
    MQTT 프로토콜
    
    - IBM 개발
    - 발행/구독 프로토콜
    - TCP/IP를 통해 실행되어 기본 네트워크 연결을 제공

1. MLFQ
2. MQTT
3. Zigbee
4. MTSP

---

- **시스템에 저장되는 패스워드들은 Hash 또는 암호화 알고리즘의 결과 값으로 저장된다. 이때 암호공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값을 의미하는 것은?**
    
    정답: 4번
    
    Hash와 Encryption 차이
    
    - Hash : 단방향, 복호화 불가능
    - Encryption : 양방향, 역으로 복호화 가능
    
    패스워드는 보통 단방향 Hash를 기본으로 저장
    
    문제점
    
    같은 패스워드를 hashing하면 같은 결과값이 나타나게되고 이는 문제를 발생함
    
    해결법
    
    이를 위해 다른 암호 값으로 저장되도록 추가되는 값 = Salt
    
    의미 그대로 소금친다는 뜻에서 Salt라고 불림
    

1. Pass flag
2. Bucket
3. Opcode
4. Salt

---

- **S/W 각 기능의 원시 코드 라인수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?**
    
    정답: 4번
    
    1. Effort Per Task 기법 - (LOC기법을 보완하기위함)각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정
    
    2. 전문가 감정 기법 - 두 명이상의 전문가에게 비용 산정을 의뢰하는 기법, 개인적이고 주관적
    
    3. 델파이 기법 - (전문가감정 기법의 주관적인 편견 보완하기위함)한명의 조정자와 여러 전문가의 의견을 종합하여 산정하는 기법
    
    4. LOC기법 - 원시코드라인수(source line of code)의 비관치, 낙관치, 기대치를 측정 예측치 구함, 본문문제내용동일.
    
    cf. 2&3의 경우 - 하향식 비용 산정 기법이며 1&4의 경우 상향식 비용 산정 기법이다.
    

1. Effort Per Task기법
2. 전문가 감정 기법
3. 델파이기법
4. LOC기법

---

- **오픈소스 웹 애플리케이션 보안 프로젝트로서 주로 웹을 통한 정보 유출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하는 곳은?**
    
    정답: 2번
    
    OWASP(The Open Web Application Security Project)는 오픈소스 웹 애플리케이션 보안 프로젝트이다. 주로 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구함
    

1. WWW
2. OWASP
3. WBSEC
4. ITU

#실기
# 정처기 실기

## 1과목 요구사항 확인

- 소프트웨어 개발 방법론
    - 소프트웨어 생명 주기 모델
        - 소프트웨어 생명 주기 정의
            
            시스템의 요구분석부터 유지보수까지 전 공정을 체계화한 절차이다.
            
        - 소프트웨어 생명주기 모델 프로세스
            - 요구사항 분석
                - 기능 요구사항
                - 비기능 요구사항
            - 설계
                - 시스템 구조 설계
                - 프로그램 설계
                - 사용자 인터페이스 설계
            - 구현
                - 인터페이스 개발
                - 자료 구조 개발
                - 오류 처리
            - 테스트
                - 단위 테스트
                - 통합 테스트
                - 시스템 테스트
                - 인수 테스트
            - 유지보수
                - 예방, 완전, 교정, 적응
                - 유지보수
        - 소프트웨어 생명주기 모델 종류
            - 폭프나반
                - 폭포수 모델
                    
                    확실히 단계를 마무리 지은 후에 다음 단계로 넘어가는 모델
                    
                    가장 오래된 모델
                    
                    선형 순차적 모형
                    
                    - 절차
                        
                        타당성 검토 → 계획 → 요구사항 분석 → 구현 → 테스트 → 유지보수
                        
                - 프로토타이핑 모델
                    
                    고객이 요구한 주요 기능을 프로토 타입으로 구현
                    
                    발주자나 개발자 모두에게 공동의 참조 모델을 제공
                    
                - 나선형 모델
                    
                    시스템 개발 시 위험을 최소화 하기 위해 점진적으로 완벽한 시스템으로 개발해 나가는 모델
                    
                    - 나선형 모델 절차
                        - 계위개고 (계의 위와 개고기가 맛있는 집)
                            
                            계획 및 정의 → 위험 분석 → 개발 → 고객 평가
                            
                - 반복적 모델
                    
                    사용자의 요구사항 일부분 혹은 제품 일부분을 반복적으로 개발하여 최종 시스템으로 완성하는 모델(병렬적으로 개발하여 개발 후 통합하기도 함)
                    
            - 소프트웨어 생명 주기 모델 간 비교
                - 절차
                    - 폭포수 모델: 요구사항 분석 → 설계 → 구현 → 테스트
                    - 프로토 타이핑 모델: 요구사항 분석 → 프로토타입 개발 → 프로토 타입 평가 → 구현 → 테스트
                    - 나선형 모델: 계획 및 정의 → 위험분석 → 개발 → 고객 평가
                    - 반복적 모델: 개발대상 → 분석 → 설계 > 구현
                - 특징
                    - 폭포수 모델: 순차적 접근
                    - 프로토 타이핑 모델: 프로토타입 개발
                    - 나선형 모델: 위험분석, 반복 개발
                    - 반복적 모델: 증분방식으로 병행 개발
                - 장점
                    - 폭포수 모델: 이해 용이, 관리 편리
                    - 프로토 타이핑 모델: 요구분석 용이, 타당성 검증 가능
                    - 나선형 모델: 위험성 감소, 변경에 유연한 대처
                    - 반복적 모델: 병행 개발로 인한 일정 단축 가능
                - 단점
                    - 폭포수 모델: 요구사항 변경 어려움
                    - 프로토 타이핑 모델: 프로토타입 폐기에 따른 비용 증가
                    - 나선형 모델: 단계 반복에 따른 관리 어려움
                    - 반복적 모델: 병행 개발에 따른 관리 비용 증가
    - 소프트웨어 개발 방법론
        - 소프트웨어 개발 방법론 정의
            - 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법
        - 소프트웨어 개발 방법론 종류
            - 구조적 방법론
                - 전체 시스템을 기능에 따라 나누어 개발하고 이를 통합하는 분할과 정복 접근 방식의 방법론
                - 프로세스 중심의 하향식 방법론
                - 구조적 프로그래밍 표현을 위해 나씨-슈나이더만 차트 사용
                    - 논리의 기술에 중점을 둔 도형식 표현 방법
                    - 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현
                    - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합
            - 정보공학 방법론
                - 정보 시스템 개발에 필요한 관리 절차와 작업 기법을 체계화한 방법론
                - 개발주기를 이용해 대형 프로젝트를 수행하는 체계적인 방법론
            - 객체 지향 방법론
                - ‘객체’라는 기본 단위로 시스템을 분석 및 설계하는 방법론
                - 복잡한 현실 세계를 사람이 이해하는 방식으로 시스템에 적용하는 방법론
                - 객체, 클래스, 메세지를 사용
            - 컴포넌트 기반 방법론
                - 소프트웨어를 구성하는 컴포넌트를 조립해서 하나의 새로운 응용 프로그램을 작성하는 방법론
                - 개발 기간 단축으로 인한 생산성 향상
                - 새로운 기능 추가 쉬움
                - 소프트웨어 재사용이 가능
            - 애자일 방법론
                - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론
                - 애자일은 개발 과정의 어려움을 극복하기 위해 적극적으로 모색한 방법론
            - 제품 계열 방법론
                - 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론
                - 임베디드 소프트웨어를 작성하는 데 유용한 방법론
                - 영역 공학과 응용 공학으로 구분
                    - 영역 공학: 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역
                    - 응용 공학: 제품 요구분석, 제품 설계, 제품을 구현하는 여역
        - 애자일
            - 애자일의 정의
                - 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론
            - 애자일 방법론 등장 배경
                - 소프트웨어 개발 환경의 변화 (시장 적시성, 잦은 배포)
                - 문서 및 절차 위주로 변화에 신속한 대응이 어려웠음
                - 빠르게 적용 및 효율적으로 개발할 수 있는 방법론의 필요성 증가
            - 애자일 방법론 유형
                - XP
                    - XP의 정의
                    - XP의 5가지 가치
                    - XP의 12가지 기본 원리
                - 린
                    - 린의 정의: 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론
                    - Jit, 칸반 보드 사용
                    - 린의 7가지 가치
                        
                        낭비 제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화
                        
                - 스크럼
                    - 매일 정해진 시간에 회의하는 방법
                    - 백로그, 스프린트, 스크럼 미팅, 스크럼 마스터, 스프린트 회고, 번 다운 차트
            - 애자일 방법론과 전통적 방법론 차이
                - 애자일: 팀 중심 업무 수행, 반복 주기, 업무 몰입, 팀 평가, 문서화 보다는 코드, 고객 가치 전달
    - 객체 지향 분석 방법론
        - 객체 지향 분석의 정의
            - 사용자의 요구사항을 분석하여 요구된 문제와 관련된 모든 클래스(객체), 속성과 연산, 관계를 정의하여 모델링하는 기법
        - 객체지향 분석 방법론 종류
            - OOSE(Object Origented Software Engineering)
                - 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용하는 방법론
                - 분석, 설계, 구현 단계로 구성
                - 기능적 요구사항 중심의 시스템
                - 만든이: 야콥슨
            - OMT(Object Modeling Technology)
                - 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론
                - 분석 절차는 객체 모델링 → 동적 모델링 → 기능 모델링 순서(객동기)
            - OOD(Object Oriented Design)
                - 설계 문서화를 강조하여 다이어그램 중심으로 처리 과정을 표현하는 모델링
                만든이: 부치
    - 비용 산정, 일정 관리 모형
        - 비용산정 모형 정의
            - 소프트웨어 규모파악을 통한 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위한 비용을 산정하는 방식
        - 비용산정 모형 분류
            - 하향식 산정방법
                - 전문가 판단
                - 델파이 기법
            - 상향식 산정 방법
                - Loc
                - Man Month
                - COCOMO 모형
                - 푸트남 모형
                - 기능 점수 모형
        - 비용산정 모형 종류
            - LoC 모형
                - 원시 코드 라인 수의 낙관치, 중간치, 비관치를 측정
            - Man Month 모형
                - 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 프로젝트 비용을 산정
            - COCOMO 모형
                - 보햄이 제안한 모형으로 프로그램 규모에 따라 비용을 산정하는 방식
                - 비용산정 결과는 Man-Month로 산정
                - 규모에 따라 조직형, 반 분리형, 임베디드 형으로 나뉨
                    - 조직형: 기관 내부에서 개발된 중, 소규모 프로젝트 (5만 라인 이하)
                    - 반분리형: 트랜젝션 처리 시스템이나 DB 관리 시스템, 컴파일러, 인터프리터와 같은 유틸 개발에 적용(30만 라인 이하)
                    - 임베디드형: 초대형 규모의 트랜젝션 처리 시스템이나 운영체제 등 (30만 라인 이상)
            - Putnam 모형
                - 단계별로 요구할 인력의 분포를 가정하는 방식
                - 생명주기 예측 모형
                - Rayleigh-Norden 곡선의 노력 분포도를 기초로 함
            - 기능점수(FP; Function Point) 모형
                - 요구 기능을 증가시키는 인자별로 가중치를 부여하고, 요인별 가중치를 합산하여 총 기능의 점수를 계산하여 비용을 산정하는 방식
                - 기능점수(FP) = 총 기능점수 x [0.65 + (0.1 x 총 영향도)]
                - 경험을 바탕으로 단순, 보통, 복잡한 정도에 가중치를 부여
        - 일정관리 모델 정의
            - 프로젝트가 일정 기한 내에 적절하게 완료될 수 있도록 관리하는 모델
        - 일정관리 모델 종류
            - 주 공정법(CPM; Critical Path Method)
                - 여러 작업의 수행 순서가 얽혀 있는 프로젝트의 일정을 계산하는 기법
                - 모든 자원 제약사항을 배제한 상태로 프로젝트의 시작과 끝을 나타내는 노드(Node)와 노드 간 연결을 통해 공정을 계산하기 위한 액티비티(Activity) 표기법
            - PERT(Program Evalutation and Review Technique)
                - 일의 순서를 게획적으로 ㅈ어리하기 위한 수령 기법으로 비관치, 중간치, 낙관치의 3점 추정 방식을 통해 일정을 관리하는 기법
            - 중요 연쇄 프로젝트 관리(CCPM: Critical Chain Project Management)
                - 주 공정 연쇄법으로 자원제약사항을 고려하여 일정을 작성하는 기법
- 현행 시스템 분석
    - 현행 시스템 파악
        - 현행 시스템 파악 정의 및 절차
            - 현행 시스템 파악 개념
            - 현행 시스템 파악 절차
                - 현행 시스템 구성/기능 및 인터페이스 파악
                - 현행 시스템 아키텍쳐 및 소프트웨어 구성 파악
                - 하드웨어 및 네트워크 구성 파악
        - 소프트웨어 아키텍처
            - 소프트웨어 아키텍쳐 정의
            - 소프트웨어 아키텍쳐 프레임워크
                - 소프트웨어 아키텍쳐 프레임워크 개념
                - 소프트웨어 아키텍쳐 프레임워크 구성 요소
                    - 아키텍쳐 명세서
                    - 이해관계자
                    - 관심사
                    - 관점
                    - 뷰
                    - 근거
                    - 목표
                    - 환경
                    - 시스템
                - 소프트웨어 아키텍쳐 4+1 뷰
                    - 유스케이스 뷰
                    - 논리 뷰
                    - 프로세스 뷰
                    - 구현 뷰
                    - 배포 뷰
            - 소프트웨어 아키텍쳐 패턴
                - 소프트웨어 아키텍쳐 정의
                - 소프트웨어 아키텍쳐 패턴 필요성
                - 소프트웨어 아키텍쳐 패턴 유형
                    - 계층화 패턴
                    - 클라이언트-서버 패턴
                    - 파이프-피렅 패턴
                    - 브로커 패턴
                    - 모델-뷰 컨트롤러 패턴
                - 소프트웨어 아키텍쳐 비용 평가 모델
                    - 소프트웨어 아키텍쳐 비용 평가 모델 정의
                    - 소프트웨어 아키텍쳐 비용 평가 모델 종류
                        - SSAM
                        - ATAM
                        - CBAM
                        - ADR
                        - ARD
        - 디자인 패턴
            - 디자인 패턴 정의
            - 디자인 패턴 구성요소
                - 패턴의 이름
                - 문제 및 배경
                - 솔루션
                - 사례
                - 결과
                - 샘플코드
            - 디자인 패턴 유형
                - 목적
                    - 생성
                    - 구조
                    - 행위
                - 범위
                    - 클래스
                    - 객체
            - 디자인 패턴 종류
                - 생성 패턴
                    - Builder
                    - Prototype
                    - Factory Method
                    - Abstract Factory
                    - Singleton
                - 구조 패턴
                    - Bridge
                    - Decorator
                    - Facade
                    - Flyweight
                    - Proxy
                    - Composite
                    - Adapter
                - 행위 패턴
                    - Mediator
                    - Interpreter
                    - Iterator
                    - Template Method
                    - Observer
                    - State
                    - Visitor
                    - Command
                    - Strategy
                    - Memento
                    - Chain of Responsibility
        - 현행 시스템 분석서 작성 및 검토
            - 현행 시스템 관련 자료수집
            - 수집 자료의 분석
            - 분석 가능한 결과를 기반으로 산출물 작성
                - 정보시스템 구성 현황
                - 정보시스템 기능 구성도
                - 인터페이스 현황
                - 현행 시스템 아키텍처 구성도
                - 소프트웨어 구성도
                - 하드웨어 구성도
                - 네트워크 구성도
            - 산출물에 대한 검토 수행
    - 개발 기술 환경 정의
        - 개발 기술 환경 현행 시스템 분석
            - 운영체제 현행 시스템 분석
                - 운영체제의 정의
                - 운영체제 현행 시스템 분석
                - 운영체제 종류 및 특징
                    - PC
                    - 모바일
            - 네트워크 현행 시스템 분석
                - 네트워크의 정의
                - OSI 7계층
            - DBMS 현행 시스템 분석
            - 미들웨어 현행 시스템 분석
            - 오픈 소스 사용 시 고려 사항
        - 개발 기술 환경 요구사항 파악
            - 기술 환경 정의를 위한 자료 수집
            - 조사 자료 분석 및 개발 기술 환경 결정
            - 요구사항 정의서, 목표 시스템 구성도 반영 및 검토
- 요구사항 확인
    - 요구사항
        - 요구사항 개념
            - 요구공학의 정의
            - 요구공학의 목적
            - 요구공학의 분류
        - 요구공학 프로세스
            - 요구사항 개발 단계 구성
                - 도분명확
            - 요구사항 개발 단계 상세
            - 요구사항 관리 단계
    - 요구사항의 시스템화 타당성 분석
        - 요구사항의 기술적 타당성 검토
        - 요구사항의 기술적 타당성 분석 프로세스
- 분석 모델 확인하기
    - 분석 검증
        - 분석 모델 검증 정의
        - 분석 모델 검증 방법
            - 유스케이스 모델 검증
            - 개념 수준의 분석 클래스 검증
            - 분석 클래스 검증
        - 분석 모델 검증 프로세스
            - 검토의견 컬럼 추가
            - 검토의견 작성
            - 검토의견 정제
    - 분석 모델의 시스템화 타당성
        - 분석 모델의 기술적 타당성 검토
        - 분석 모델의 시스템화 타당성 분석 프로세스

## 2과목 화면 설계

- UI 요구사항 확인
    - UI 요구사항 확인
        - UI 정의
        - UI 유형
            - CLI
            - GUI
            - NUI
            - OUI
        - UI 분야
        - UI 설계 원칙
        - UI 설계 지침
        - UI 요구사항 확인
            - UI 요구사항 정의
            - UI 요구사항 구분
                - 기능적 요구사항
                - 비기능적 요구사항
            - UI 품질 요구사항 특징
                - 기능성
                    - 적절성
                    - 정밀성
                    - 상호 운용성
                    - 보안성
                    - 호환성
                - 신뢰성
                    - 성숙성
                    - 고장 허용성
                    - 회복성
                - 사용성
                    - 이해성
                    - 학습성
                    - 운용성
                - 효율성
                    - 시간 효율성
                    - 자원 효율성
                - 유지보수성
                    - 분석성
                    - 변경성
                    - 안정성
                    - 시험성
                - 이식성
                    - 적용성
                    - 설치성
                    - 대체성
    - UI 표준
        - UI 표준 정의
            
            
        - UI 표준 구성
        - UI 표준 수립 시 고려사항
        - UI 스타일 가이드 구성
            - UI 환경의 정의
                - UI 구동 환경의 정의
                    - 운영체제(OS) 확인
                    - 웹 브라우저 확인
                    - 모니터 해상도 확인
                    - 프레임 세트 확인
                        - 프레임 세트 적용
                            - 프레임 구분
                            - 단일 프레임
                                
                                
                            - 웹 애플리케이션 경우
                            
                - 레이아웃 정의
                    - 레이아웃 정의
                        - 상단 메뉴 구성 정의
                        - 좌측 메뉴 구성 정의
                        - 내용 구성 정의
                        - 하단 메뉴 구성 정의
                - 메뉴 내비게이션 정의
                - 공통표준화면 정의
                - 기능 정의
                - 구성요소 정의
            - 레이아웃 정의
        - UI 패턴 모델(Pattern Model) 정의
        - UI 표준 수립을 위한 조직의 구성
    - UI 지침
        - UI 지침 정의
        - UI 표준 적용을 위한 환경 분석
        - UI 개발 목표 및 범위
        - 사용자 분석 및 니즈(Needs) 조사
        - 사용자 요구사항 도출
        - UI 상세 설계
        - UI 화면 디자인
        - UI 시연을 통한 사용자 검토/검증
        - 테스트, 배포 및 관리
    - 스토리 보드
        - 스토리보드 정의
            - UI 화면 설계 구분
        - 스토리보드 작성 절차
        - 스토리보드 작성 시 유의 사항
        - 스토리보드 작성 사례
    - UI 프로토타입 제작 및 검토
        - UI 프로토타입의 이해
            - 프로토타입 정의
            - 프로토타입 의의
            - 프로토타입의 장점 및 단점
            - UI
- UI 설계
    - UI 설계를 위한 UML
        - UML
            - UML의 정의
            - UML의 특징
            - UML의 구성요소
            - **UML 다이어그램**
            - ********************************************************************************UML 확장 모델의 스테레오 타입********************************************************************************
        - UML의 유형
            - **클래스 다이어그램**
                - **클래스 다이어그램 정의**
                - **클래스 다이어그램 구성요소**
                - **클래스간의 관계**
            - 유스케이스 다이어그램
            - **시퀀스 다이어그램**
                - 시퀀스 다이어그램 정의
                - 시퀀스 다이어그램 구성요소
            - 패키지 다이어그램
                - 패키지 다이어그램 정의
                    
                    패키지 다이어그램 구성요소
                    
            - 활동 다이어그램
                - 활동 다이어그램 정의
                - 활동 다이어그램 구성요소
            - 상태 다이어그램
            - 커뮤니케이션 다이어그램
            - 컴포넌트 다이어그램
    - UI 흐름 설계
        - UI 설계서 구성
        - UI 흐름 설계 수행 절차
    - UI 상세 설계
        - UI 상세 설계 프로세스
        - UI 검토 및 보안
        - UI 시나리오 문서의 작성 요건
    - UI 설계 도구
        - UI 설계 도구의 개념
        - UI 개발 단계별 활용 가능한 설계 도구
        - UI 설계 도구의 유형

## 3과목: 데이터 입출력 구현

- 논리 데이터 저장소 확인
    - 데이터 모델
    - 논리 데이터 모델 검증
- 물리 데이터 저장소 설계
    - 물리 데이터 모델 설계
    - 물리 데이터 저장소 구성
- 데이터베이스 기초 활용하기
    - 데이터 베이스 종류

## 4과목: 통합 구현

- 연계 데이터 구성
    - 연계 데이터 요구사항 분석
    - 연계 데이터 식별 및 표준화
- 연계 메커니즘 구성
    - 연계 메커니즘 정의
    - 연계 장애 및 오류 처리 구현
- 내외부 연계 모듈 구현
    - 연계 모듈 구현 환경 구성 및 개발
    - 연계 테스트 및 검증

## 5과목: 인터페이스 구현

- 인터페이스 설계 확인
    - 외부, 내부 모듈 간 공통 기능 및 데이터 인터페이스 확인
    - 외부 및 내부 모듈 연계를 위한 인터페이스 기능 식별
    - 외부 및 내부 모듈 간 인터페이스 데이터 표준 확인
- 인터페이스 기능 구현
    - 인터페이스 기능 구현 정의
    - 인터페이스 기능 구현
    - 인터페이스 예외 처리 방안
    - 인터페이스 보안 기능 적용
- 인터페이스 구현 검증
    - 인터페이스 구현 검증
    - 인터페이스 오류 처리 확인 및 보고서 작성

## 6과목: 프로그래밍 언어 활용

- 기본 문법 활용하기
    - 프로그래밍을 위한 기본 사항
    - 변수 활용
    - 연산자
    - 표준 함수
    - 명령문
    - 사용저 정의 자료형 활용
    - 사용자 정의 함수
    - 재귀 함수
    - 클래스(Class)

## 7과목: SQL 응용

- 데이터베이스 기본
    - 트랜잭션
        - 트랜잭션의 정의
        - 트랜잭션의 특성
        - 트랜잭션의 상태 변화
        - 트랜잭션 제어
        - 병행 제어
        - 데이터베이스 고립화 수준(격리성 주요 기법)
        - 회복 기법(영속성 주요 기법)
    - DDL
        - DDL의 정의
        - DDL의 대상
        - DDL 명령어
        - TABLE 관련 DDL
        - INDEX 관련 DDL
    - DML
        - DML 정의
        - DML 명령어
        - SELECT(조회) 명령어
        - INSERT(데이터 삽입) 명령어
        - UPDATE(데이터 변경) 명령어
        - DELETE(데이터 삭제) 명령어
    - DCL
        - DCL 정의
        - DCL 유형
- 응용 SQL 작성하기
    - 집계성 SQL 작성
        - 데이터 분석 함수의 정의
        - 데이터 분석 함수 종류
        - 집계 함수
        - 그룹 함수
        - 윈도 함수
- 절차형 SQL 작성하기
    - 절차형 SQL
        - 절차형 SQL 정의
        - 절차형 SQL 종류
        - 출력부
        - 제어부
    - 프로시저
        - 프로시저 정의
        - 프로시저 구성
        - 프로시저 문법
        - 프로시저 호출문 작성
    - 사용자 정의 함수
        - 사용자 정의 함수 정의
        - 사용자 정의 함수 구성
        - 사용자 정의 함수 문법
    - 트리거
        - 트리거의 정의
        - 트리거의 목적
        - 트리거의 종류
        - 트리거의 구성
        - 트리거 문법
        - 트리거 작성 시 주의사항
- 데이터 조작 프로시저 최적화
    - 데이터 조작 프로시저 성능개선
        - 쿼리 성능 개선(튜닝)의 정의
        - 쿼리 성능 개선 절차
        - 옵티마이저 통계 확인
        - SQL문 재구성
        - 인덱스 재구성

## 8과목: 서버 프로그램 구현

- 개발환경 구축
    - 개발환경 구축의 정의
    - 개발 도구의 분류
    - 개발환경 구성요소
    - 개발환경 구축 절차
- 공통 모듈 구현
    - 공통모듈 구현의 개념
    - 소프트웨어 모듈 응집도
    - 소프트웨어 모듈 결합도
    - 공통 모듈 구현 대상
    - 공통 모듈 구현 절차
    - 팬인(Fan-In) 및 팬아웃(Fan-Out)
- 공통 모듈 테스트
    - 공통 모듈 테스트의 개념
    - 공통 모듈 테스트의 종류
    - 공통 모듈 테스트 구현
- 서버 프로그램 구현
    - 서버 프로그램 구현의 개념
    - 서버 프로그램 구현 절차
    - 서버 프로그램 세부 구현
- 배치 프로그램 구현
    - 배치 프로그램의 개념
    - 배치 프로그램의 유형
    - 배치 스케줄러
    - 배치 프로그램 설계
    - 배치 프로그램 작성

## 9과목: 소프트웨어 개발 보안 구축

- 소프트웨어 개발 보안 설계
    - SW 개발 보안의 개념
    - SW 개발 보안의 구성 요소
    - SW 개발 보안을 위한 공격기법의 이해
    - 서버 인증 및 접근 통제
    - SW 개발 보안을 위한 암호화 알고리즘
    - 안전한 전송을 위한 데이터 암호화 전송
    - 자산에 대한 보안 항목식별
    - SW 개발 보안 적용 사례
    
- 소프트웨어 개발 보안 구현
    - SW 개발 보안 구현
        - 시큐어 코딩 가이드
        - 입력 데이터 검증 및 표현
        - 보안 기능
        - 에러 처리
        - 세션 통제
        - 코드 오류
        - 캡슐화
        - API 오용
    - 시스템 보안 구현
        - 유닉스/리눅스 주요 로그 파일
        - 보안 솔루션
        - 취약점 분석
    - SW 개발 보안 테스트와 결함 관리
        - 소프트웨어 개발 보안 테스트의 개념
        - 소프트웨어 개발 보안 테스트의 유형
        - 소프트웨어 개발 보안 테스트 절차
    - 비즈니스 연속성 계획(BCP)
        - 비즈니스 연속성 계획의 개념
        - 비즈니스 연속성 계획 관련 주요 용어
    - 보안 주요 용어

## 10과목: 애플리케이션 테스트 관리

- 애플리케이션 테스트 케이스 설계
    - 애플리케이션 테스트 케이스 작성
        - 소프트웨어 테스트의 이해
        - 소프트웨어 테스트 유형
        - 정적 테스트
        - 동적 테스트
        - 테스트 케이스
        - 테스트 오라클
    - 애플리케이션 테스트 시나리오 작성
        - 테스트 레벨
        - 테스트 시나리오
        - 테스트 환경 구축
- 애플리케이션 통합 테스트
    - 애플리케이션 테스트 수행
        - 단위 테스트
        - 통합 테스트
        - 테스트 자동화 도구
    - 애플리케이션 테스트 결과 분석
        - 테스트 결과 분석
        - 결함 관리
        - 결함 추이 분석
    - 애플리케이션 개선 조치사항 작성
        - 테스트 커버리지
        - 결함의 식별 및 관리
- 애플리케이션 성능 개선
    - 애플리케이션 성능 분석
        - 애플리케이션 성능 점검 개요
        - 애플리케이션 성능 저하 원인
        - 애플리케이션 성능 테스트 프로세스
    - 애플리케이션 성능 개선
        - 소스 코드 최적화의 이해
        - 소스 코드 품질분석
        - 애플리케이션 성능 개선 방안

## 11과목: 응용 SW 기초 기술 활용

- 운영체제 특징
- 네트워크 기초 활용하기
- 기본 개발환경 구축하기

## 12과목: 제품 소프트웨어 패키징

- 제품 소프트웨어 패키징하기
- 제품 소프트웨어 매뉴얼 작성 및 버전 등록

---
