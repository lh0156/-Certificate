# 🗂정처기 오답노트

# 1과목(소프트웨어 설계)

- **시스템의 구성요소로 볼 수 없는 것은?**
    
    정답: 3번
    
    시스템 구성요소
    
    입력 (Input) : 처리 방법, 처리할 데이터, 조건을 시스템에 투입하는 것
    
    처리 (Process) : 입력된 데이터를 처리 방법과 조건에 따라 처리하는 것
    
    출력 (Output) : 처리된 결과를 시스템에서 산출하는 것
    
    제어 (Control) : 자료를 입력하여 출력될 때까지의 처리 과정이 올바르게 진행되는지 감독하는 것
    
    피드백 (Feedback) : 출력된 결과가 예정된 목표를 만족시키지 못할 경우 목표 달성을 위해 반복 처리하는 것
    
    Maintenance는 유지보수로서, 시스템 구성요소에는 포함되지 않음.
    

1. Process
2. FeedBack
3. Maintenance
4. Control

---

- **유스케이스(Usecase)에 대한 설명 중 옳은 것은?**
    
    정답: 2번
    
    유스케이스는 시스템이 액터에게 제공해야 하는 기능으로, 시스템의 요구사항이자 기능을 의미
    
    유스케이스 다이어그램은 사용자의 요구를 추출하고 분석하기 위해 주요 사용
    
    여기서 **액터는 시스템 외부에서 시스템과 상호작용하는 사람 혹은 시스템**을 말함
    
    사용자 액터: 기능을 요구하는 대상이나 시스템의 수행결과를 통보받는 사용자 혹은 기능을 사용하게 될 대상으로 시스템이 제공해야하는 기능인 유스케이스의 권한을 가지는 대상, 역할
    
    시스템 액터: 사용자 액터가 사용한 유스케이스를 처리해주는 외부 시스템, 시스템의 기능 수행을 위해서 연동이 되는 또 다른 시스템 액터를 의미
    
    [해설작성자 : 컴린이]
    
    액터?
    
    - 시스템과 상호작용을 하는 모든 외부 요소로, 사람이나 외부 시스템을 의미
    - 주액터(사용자 액터)
    - 부액터(시스템 액터)
    
    1번 개발자의 요구X   사용자의 요구O
    
    3번 부액터(시스템 액터) 설명임
    
    4번 일방적X  양방향O
    

1. 유스케이스 다이어그램은 개발자의 요구를 추출하고 분석하기 위해 주로 사용한다
2. 엑터는 대상 시스템과 상호 작용하는 다른 사람이나 시스템에 의한 역할이다.
3. 사용자 액터는 본 시스템과 데이터를 주고받는 연동 시스템을 의미한다.
4. 연동의 개념은 일방적으로 데이터를 파일이나 정해진 형식으로 넘겨주는 것을 의미한다.

---

- **요구사항 개발 프로세스의 순서로 옳은 것은?**
    
    정답: 1번
    
    요구사항을 “도출"해야 “분석"하고, 분석해야 자세히 쓸 수 있고(명세), 명세를 검토해야 한다.
    
    **도분명확**
    

![Untitled](%F0%9F%97%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8E%E1%85%A5%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3%20537e7630861e45e085dd1abe16fa15b5/Untitled.png)

1. ㄱ-ㄴ-ㄷ-ㄹ
2. ㄱ-ㄷ-ㄴ-ㄹ
3. ㄱ-ㄹ-ㄴ-ㄷ
4. ㄱ-ㄴ-ㄹ-ㄷ

---

- **GoF (Gangs of Four) 디자인 패턴에 대한 설명으로 틀린 것은?**
    
    정답: 3번
    
    bridge pattern은 구현부에서 추상층을 분리하여 각자 독립적으로 확장이 가능하게 하는 패턴이다
    
    [해설작성자 : comcbt.com 이용자]
    
    3은 Adapter pattern의 설명
    

1. factory method pattern은 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식이다.
2. prototype pattern은 prototype을 먼저 생성하고 인스턴스를 복제하여 사용하는 구조이다.
3. bridge pattern은 기존에 구현되어 있는 클래스에 기능 발생 시 기존 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 한다.
4. mediator pattern은 객체간의 통제와 지시의 역할을 하는 중재자를 두어 객체지향의 목표를 달성하게 해준다.

---

- 자료 흐름도의 각 요소별 표기법은?
    
    Process = 데이터를 원하는 혀앹로 변환하여 풀력하기 위한 과정: 원 ㅇ
    
    Data Flow = 구성요소간의 주고받는 데이터 흐름: 화살표 →
    
    Data Store = 데이터가 저장된 장소: 평행선 =
    
    Terminator = 시작과 종료: 사각형
    

---

- **CASE(Computer-Aided Software Engineering)의 원천 기술이 아닌 것은?**
    
    정답: 4번
    
    Case의 원천 기술은 구조적 기법, 프로토타이핑 기술, 자동프로그래밍 기술, 정보 저장소 기술, 분산 처리 기술이 있다 (구프자정분)
    

1. 구조적 기법
2. 프로토타이핑 기술
3. 정보 저장소 기술
4. 일괄처리 기술

---

- **UML 다이어그램이 아닌 것은?**
    
    정답 :2번
    
    업무의 흐름을 모델링하거나 객체의 생명 주기를 표현하는 Activity 다이어그램
    
    객체 간의 메시지 전달을 시간적 흐름에서 분석하는 Sequence 다이어그램
    
    기업 환경의 구성과 컴포넌트들 간의 관계를 그린 Deployment 다이어그램
    
    객체와 객체가 주고받는 메시지 중심의 작성 동적 다이어그램인 Collaboration 다이어그램
    
    소프트웨어 구조가 그리는 Component 다이어그램
    
    시스템의 구조적인 모습을 그리는 Class 다이어그램
    

1. 액티비티 다이어그램(Activity diagram)
2. 절차 다이어그램(Procedural diagram)
3. 클래스 다이어그램(Class diagram)
4. 시퀀스 다이어그램(Sequence diagram)

---

- **UML 모델에서 한 객체가 다른 객체에게 오퍼레이션을 수행하도록 지정하는 의미적 관계로 옳은 것은?**
    
    정답: 2번
    
    Dependency(의존) : 한 사물의 명세서가 바뀌면 그것을 사용하는 다른 사물에게 영향을 끼치는 것을 말합니다 
    
    Realization(실체화) : 한 객체가 다른 객체에 의해 오퍼레이션을 수행하도록 지정
    
    Generalization(일반화) : 일반화된 사물과 좀 더 특수화된 사물 사이의 관계를 말합니다.('is-a')관계
    
    Association(연관) : 두 사물간의 구조적 관계로, 어느 한 사물 객체가 다른 사물 객체와 연결되어 있음을 말함 ('has-a')관계라고도 합니다
    
    [해설작성자 : 정규직되고파]
    

1. Dependency
2. Realization
3. Generalization
4. Association

---

- 애자일 개발 방법론이 아닌 것은?
    
    정답: 4번
    
    애자일 개발 방법론
    
    익스트림 프로그래밍(XP , Extreme Programming)
    
    스크럼크리스털 패밀리
    
    기능 주도 개발(FDD , Feature-Driven Development)
    
    적응형 소프트웨어 개발 (ASD , Adaptive Software Development(
    
    익스트림 모델링
    
    하둡(Hadoop)
    
    분산 환경에서 빅 데이터를 저장하고 처리할 수 있는 자바 기반의 오픈 소스 프레임 워크.
    

1. 스크럼(Scrum)
2. 익스트림 프로그래밍(XP, eXtreme Programming)
3. 기능 주도 개발(FOD, Feature Driven Development)
4. 하둡(Hadoop)

---

- **다음 중 물리적 시스템을 구성하고 있는 각 부분들의 분산 형태와 설치에 초점을 두는 소프트웨어 아키텍처 4+1 뷰는 무엇인가?**
    
    [제목 없음](https://www.notion.so/82b0d0d904e94b4490127dc964583443)
    
1. Usecase View
2. Deployment View
3. Logical View
4. Process View

---

- GoF(Gangs of Four)디자인 패턴 중 생성패턴으로 옳은 것은?
    
    정답: 1번
    
    생성패턴: 객체를 생성하는 것에 대한 패턴
    
    추상팩토리 패턴, 빌더 패턴, 팩토리 메소드 패턴, 프로토타입 패턴, 싱글톤 패턴
    
    구조 패턴: 구조를 통해 확장성을 꾀하는 패턴
    
    어댑터 패턴, 브릿지 패턴, 컴포지트 패턴, 데코레이터 패턴, 퍼사드 패턴, 플라이웨잇 패턴, 프록시 패턴
    
    행위 패턴: 행위의 변경, 수정 등을 위한 패턴
    
    역할 사슬 패턴, 커맨드 패턴, 인터프리터 패턴, 이터레이터 패턴, 미디에이터 패턴, 메멘토 패턴, 옵저버 패턴, 스테이트 패턴, 스트래티지 패턴, 템플릿 메소드 패턴, 비지터 패턴
    
    [해설작성자 : 컴린이]
    
    1. singleton pattern(단일체): 한 클래스에 한 객체만 존재하도록 제한한다(생성패턴)
    
    2. adapter pattern(적응자): 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록, 타 클래스의 인터페이스를 기존 인터페이스에 덧씌운다(구조패턴)
    
    3. decorator pattern(장식자): 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용할 수 있다(구조패턴)
    
    4. state pattern(상태): 동일한 동작을 객체의 상태에 따라 다르게 처리해야 할 때 사용하는 디자인 패턴(행위패턴)
    

1. singleton pattern
2. dapter pattern
3. decorator pattern
4. state pattern

---

- **소프트웨어 설계에서 사용되는 대표적인 추상화(Abstraction) 기법이 아닌 것은?**
    
    정답: 4
    
    <문제 해설>
    
    제어 추상화: 제어의 정확한 메커니즘을 정의하지 않고 원하는 효과를 정하는데 이용하는 방법
    
    기능 추상화: 입력 자료를 출력자료로 변환하는 과정을 추상화하는 방법
    
    자료 추상화: 자료와 자료에 적용될 수 있는 기능을 함께 정의함으로써 자료 객체를 구성하는 방법
    

1. 자료 추상화
2. 제어 추상화
3. 과정 추상화
4. 강도 추상화

---

- **요구 분석(Requirement Analysis)에 대한 설명으로 틀린 것은?**
    
    **정답: 4**
    
    <문제 해설>
    
    기능적 요구사항- 시스템이 수행해야 하는 행위들을 구체화 한 것- 시스템에서 제공해야 할 기능을 정의한 것- 입력기능, 출력기능, 데이터베이스 기능, 통신 기능 등비기능적 요구사항- 시스템이 가져야 하는 기능 이외의 요구사항- 시스템의 전체적인 품질이나 고려해야 하는 제약사항 등- 사용 용이성, 효율성, 신뢰성, 이식성, 유연성, 확장성 등- 성능적인 면: 응답 속도, 자원 사용량 등- 보안 측면: 침입 대응, 침입 탐지, 사용자 인증, 권한 부여 등
    

1. 요구 분석은 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대해 이해하는 단계라 할 수 있다.
2. 요구 추출(Requirement Elicitation)은 프로젝트 계획 단계에 정의한 문제의 범위 안에 있는 사용자의 요구를 찾는 단계이다.
3. 도메인 분석(Domain Analysis)은 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링을 하게 된다.
4. 기능적(Functional) 요구에서 시스템 구축에대한 성능, 보안, 품질, 안정 등에 대한 요구사항을 도출한다.

---

- **클래스 다이어그램의 요소로 다음 설명에 해당하는 용어는?**
    
    정답: 2
    
    작동, 동작 = 오퍼레이션
    

> 클래스의 동작을 의미한다
> 

> 클래스에 속하는 객채에 대하여 적용될 메서들르 정의한 것이다
> 

> UML에서는 동작에 대한 인터페이스를 지칭한다고 볼 수 있다.
> 
1. Instance
2. Operation
3. Item
4. Hiding

---

- **다음 중 UML 다이어그램 중 동적 다이어그램이 아닌 것은?**
    
    동 유시커상활타
    
    정 클객컴배복패
    
1. 커뮤니케이션 다이어그램
2. 배치 다이어그램
3. 활동 다이어그램
4. 유스케이스 다이어그램

---

- **요구 사항 정의 및 분석·설계의 결과물을 표현하기 위한 모델링 과정에서 사용되는 다이어그램(Diagram)이 아닌 것은?**
    
    정답: 4
    
    avl 트리는 이진 트리의 높낮이가 불규칙해지는 것을 보완하여
    
    일정하게 처리하기 위한 이진트리 모형이다.
    

1. Data Flow Diagram
2. UML Diagram
3. E-R Diagram
4. AVL Diagram

---

- **GoF(Gang of Four) 디자인 패턴과 관련한 설명으로 틀린 것은?**
    
    정답: 2번
    
    GoF(Gang of Four) 패턴: 에리히 감마(Erich Gamma), 리처드 헬름(Richard Helm), 랄프 존슨(Ralph Johnson), 존 블리시데스(John Vlissides)가 같이 고안한 디자인 패턴
    
    23가지 디자인 패턴을 3가지 분류로 정리한 디자인 패턴
    
    - 생성 패턴: Abstract Factory, Builder, Factory Method, Prototype, Singleton
    - 구조 패턴: Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
    - 행위 패턴: Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategty, Template Method, Visitor
    
    보기 2번의 Strategy 패턴은 행위 패턴에 해당
    
    [해설작성자 : 이거까지알아야해?]
    
    디자인 패턴 = 생구행을떠올리자
    
    생(성) - 추빌팩프싱      *추 : Abstract Factory(추상팩토리)
    
    구(조) - 어브컴데퍼플프
    
    행(위) - 위에 2개 해당안하면 행위패턴임
    

1. 디자인 패턴을 목적(Purpose)으로 분류할 때 생성, 구조, 행위로 분류할 수 있다.
2. Strategy 패턴은 대표적인 구조 패턴으로 인스턴스를 복제하여 사용하는 구조를 말한다.
3. 행위 패턴은 클래스나 객체들이 상호작용하는 방법과 책임을 분산하는 방법을 정의한다.
4. Singleton 패턴은 특정 클래스의 인스턴스가 오직 하나임을 보장하고, 이 인스턴스에 대한 접근 방법을 제공한다.

---

- **럼바우(Rumbaugh)의 객체지향 분석 기법 중 자료 흐름도(DFD)를 주로 이용하는 것은?**
    
    정답: 1번
    
    럼바우 분석기법
    
    객,동,기
    
    객체모델링 = 객체 다이어그램
    
    동적모델링 = 상태 다이어그램
    
    기능 모델링 = 자료흐름도
    

1. 기능 모델링
2. 동적 모델링
3. 객체 모델링
4. 정적 모델링

---

- **객체지향 분석 기법과 관련한 설명으로 틀린것은?**
    
    정답: 2번
    
    2번은 순차적인 하향식 처리방식이기 때문에 절차지향 분석 기법
    

1. 동적 모델링 기법이 사용될 수 있다.
2. 기능 중심으로 시스템을 파악하며 순차적인처리가 중요시되는 하향식(Top-down)방식으로 볼 수 있다.
3. 데이터와 행위를 하나로 묶어 객체를 정의내리고 추상화시키는 작업이라 할 수 있다.
4. 코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템의 쉬운 변경이 가능하다.

---

- **대표적으로 DOS 및 Unix 등의 운영체제에서조작을 위해 사용하던 것으로, 정해진 명령문자열을 입력하여 시스템을 조작하는 사용자인터페이스(User Interface)는?**
    
    정답: 2번
    
    GUI(Graphical User Interface) : 사용자가 편리하게 사용할 수 있도록 입출력 등의 기능을 알기 쉬운 아이콘 따위의 그래픽으로 나타낸 것
    
    CLI(Command Line Interface) : 텍스트 터미널을 통해 사용자와 컴퓨터가 명령문자열로 상호 작용하는 방식
    

1. GUI(Graphical User Interface)
2. CLI(Command Line Interface)
3. CUI(Cell User Interface)
4. MUI(Mobile User Interface)

---

- **소프트웨어 아키텍처와 관련한 설명으로 틀린것은?**
    
    정답: 1번
    
    파이프 필터 아키텍처에서 데이터는 파이프를 통해 단방향으로 흐르고, 필터 이동시 오버헤드가 발생될 수 있음.
    
    (파이프 모양의 컵에 물을 계속 따르면 물이 넘쳐 흐르는것 처럼...)
    

1. 파이프 필터 아키텍처에서 데이터는 파이프를 통해 양방향으로 흐르며, 필터 이동 시 오버헤드가 발생하지 않는다.
2. 외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기본 구조로 볼수 있다.
3. 데이터 중심 아키텍처는 공유 데이터저장소를 통해 접근자 간의 통신이 이루어지므로 각 접근자의 수정과 확장이 용이하다.
4. 이해 관계자들의 품질 요구사항을 반영하여품질 속성을 결정한다.

---

- **다음 중 대상 자료의 물리적인 수치인 길이, 넓이, 용량 등을 표시한 코드는 무엇인가?**
    
    정답: 3번 Significant Digit Code 표의 숫자 코드!
    
1. Mnemonic Code
2. Block Code
3. Significant Digit Code
4. Decimal Code

---

- **CASE(Computer-Aided Software Engineering)의 원천 기술에 대한 설명으로 올바르지 않은 것은?**
    
    정답: 3번
    
    CASE 원천 기술 (Computer-Aided Software Engineering) 구프자정
    
    - 구조적 기법 - 하향식, 기능식 분해 방법을 이용하여 시스템의 요구를 정의하는 모델링 기법
    - Prototyping 기술 - CASE 도구가 Client/Server 환경에서 제공되어 다수의 사용자가 CASE 도구와 개발 정보를 공동 사용하게 하기 위하여 분산 환경에서의 처리 기술
    - 자동 Programming 기술 - 설계한 내용을 기초로 프로그램을 자동 생성하는 기술
    - 정보 저장소 기술 - SW를 개발하는 동안에 모아진 정보를 보관하여 관리하는 기술
    
    분산 처리 기술 - CASE 도구가 Client/Server 환경에서 제공되어 다수의 사용자가 CASE 도구와 개발 정보를 공동 사용하게 하기 위하여 분산 환경에서의 처리 기술
    
1. 구조적 기법 : 하향식, 기능식 분해 방법을 이용하여 시스템의 요구를 정의하는 모델링 기법
2. 자동 Programming 기술 : 설계한 내용을 기초로 프로그램을 자동 생성하는 기술
3. 정보 저장소 기술 : CASE 도구가 Client/Server 환경에서 제공되어 다수의 사용자가 CASE 도구와 개발 정보를 공동 사용하게 하기 위하여 분산 환경에서의 처리 기술
4. Prototyping 기술 : 시제품(prototype) 형태의 SW를 단기간에 제작하여 사용자에게 제시함으로써 요구 사항에 대한 빠른 확정과 개발을 진행할 수 있는 기술

---

# 2과목(소프트웨어 개발)

- **힙 정렬(Heap Sort)에 대한 설명으로 틀린것은?**
    
    정답: 4번
    
    최악 : O(nlog n)
    
    [해설작성자 : 꿀유자]
    
    힙 정렬(Heap Sort) : 평균과 최악 모두 시간 복잡도는 O(nlog2n)
    

1. 정렬할 입력 레코드들로 힙을 구성하고 가장 큰 키 값을 갖는 루트 노드를 제거하는 과정을 반복하여 정렬하는 기법이다
2. 평균 수행 시간은 O(nlog2n)이다.
3. 완전 이진트리(complete binary tree)로 입력자료의 레코드를 구성한다.
4. 최악의 수행 시간은 O(2n4)이다.

---

- **소프트웨어 테스트와 관련한 설명으로 틀린것은?**
    
    정답: 4번
    
    화이트 박스 테스트 : 내부 구조와 동작을 검사하는 테스트 방식, 소프트웨어의 내부 소스를 테스트
    
    블랙 박스 테스트 : 내부 구조나 작동 원리를 모르는 상태에서 입력에 따른 출력 결과를 테스트
    
    4. 화이트 박스 테스트에서 기본 경로는 싸이클을 최대 한번만 지나야한다.
    
    [해설작성자 : 해군본부 정체단 674기 수뱅]
    
    화이트박스테스트는 내부의 논리적인 모든 경로를 테스트해 테스트 케이스를 설계함.
    

1. 화이트 박스 테스트는 모듈의 논리적인 구조를 체계적으로 점검할 수 있다.
2. 블랙박스 테스트는 프로그램의 구조를 고려하지 않는다
3. 테스트 케이스에는 일반적으로 시험 조건, 테스트 데이터, 예상 결과가 포함되어야 한다.
4. 화이트박스 테스트에서 기본 경로(BasisPath)란 흐름 그래프의 시작 노드에서 종료노드까지의 서로 독립된 경로로 싸이클을 허용하지 않는 경로를 말한다.

---

- 화이트 박스 테스트에 대해서 설명하시오
    
    각 응용 프로그램의 내부 구조와 동작을 검사하는 소프트웨어 테스트
    
    구결조 조변다 기제데
    
    구문 커버리지
    
    결정 커버리지
    
    조건 커버리지
    
    조건/결정 커버리지
    
    변경 조건/결정 커버리지
    
    다중조건 커버리지
    
    (이들을 제어 흐름 테스트라고 함)
    
    기본경로 커버리지
    
    제어흐름 테스트
    
    데이터 흐름 테스트
    

---

- 블랙 박스 테스트에 대해서 설명하시오
    
    프로그램 외부 사용자의 요구 사항 명세를 보면서 수행하는 테스트
    
    동경결상 유분페원비
    
    동등 분할 테스트
    
    경곗값 분석 테스특
    
    결정 테이블 테스트
    
    상태전이 테스트
    
    유스케이스 테스트
    
    분류 트리 테스트
    
    페어와이즈 테스트
    
    원인-결과 그래프 테스트
    
    비교 테스트
    

---

- **디지털 저작권 관리(DRM) 구성 요소가 아닌 것은?**
    
    정답: 1번
    
    [저작권 관리구성요소]
    
    - 콘텐츠 분배자: 암호화된 콘텐츠를 유통하는곳/사람
    - 패키저: 콘텐츠를 메타데이터와 함께 배포가능한 형태로 묶어 암호화
    - 클리어링 하우스: 키 관리 및 라이센스 발급 관리
    - DRM 컨트롤러: 배포된 콘텐츠의 이용권한을 통제
    
    [해설작성자 : 코로그]
    
    클리어링 하우스(Clearing House) : 디지털 저작권 라이선스의 중개 및 발급을 수행하는 곳, 디지털 저작물의 이용 내역을 근거로 저작권료의 정산 및 분배가 수행된다. Dataware house 아님
    

1. Dataware house
2. DRM Controller
3. Packager
4. Contents Distributor

---

- **다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 Pass 2의 결과는?**
    
    정답: 4번
    
    Pass 1  9 6 7 3 5  →  6 9 7 3 5  →  6 7 9 3 5  →  6 7 3 9 5  →  6 7 3 5 9
    
    Pass 2  6 7 3 5 9  →  6 3 7 5 9  →  6 3 5 7 9
    
    [해설작성자 : comcbt.com 이용자]
    
    버블 정렬은 첫 번째 자료와 두 번째 자료를, 두 번째 자료와 세 번째 자료를, 세 번째와 네 번째를, … 이런 식으로 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬한다.
    
    [해설작성자 : 쀼쮸]
    

              9, 6, 7, 3, 5

1. 3, 5, 6, 7, 9
2. 6, 7, 3, 5, 9
3. 3, 5, 9, 6, 7
4. 6, 3, 5, 7, 9

---

- **정렬된 N개의 데이터를 처리하는 데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?**
    
    정답: 1번
    
    O(N*log2N) : 선형 로그형 복잡도 : 로그,변수에 비례 ⇒ 퀵정렬,병합정렬
    
    O(N2) : 제곱형 : 제곱에 비례 ⇒ 버블정렬, 삽입정렬, 선택정렬
    
    정렬된 데이터의 경우, 버블정렬과 삽입정렬은 O(N) 이 될 수 있음
    

1. 합병정렬
2. 버블정렬
3. 선택정렬
4. 삽입정렬

---

- 인터페이스 구현 검증 도구가 아닌 것은?
    
    정답: 1번
    
    인터페이스 구현 검증 도구는 xUnit, STAF, Fitnesse, NTAF, Selenium, watir 등이 있습니다.
    
    Foxbase는 프로그래밍 언어입니다.
    

1. Foxbase
2. STAF
3. watir
4. xUnit

---

- 테스트와 디버그의 목적으로 옳은 것은?
    
    정답: 1번
    
    Coding
    
    → Testing
    
    → Error 발생 (== Bug 발견)
    
    → Error 수정 (== Debugging)
    
    → Retesting
    

1. 테스트는 오류를 찾는 작업이고 디버깅은 오류를 수정하는 작업이다.
2. 테스트는 오류를 수정하는 작업이고 디버깅은 오류를 찾는 작업이다.
3. 둘 다 소프트웨어의 오류를 찾는 작업으로 오류 수정은 하지 않는다.
4. 둘 다 소프트웨어 오류의 발견, 수정과 무관하다.

---

- **다음 자료를 버블 정렬을 이용하여 오름차순으로 정렬할 경우 PASS 3의 결과는?**
    
    버블 정렬(Bubble Sort)
    
    : 인접한 데이터를 비교하면서 데이터의 위치를 바꾸어 정렬하는 방법
    
    한번의 Pass 내에서 다수의 교체 발생
    
    Pass 1: 6 7 3 5 9
    
    Pass 2: 6 3 5 7 9
    
    Pass 3: 3 5 6 7 9
    

> 9, 6, 7, 3, 5
> 
1. 6, 3, 5, 7, 9
2. 3, 5, 6, 7, 9
3. 6, 7, 3, 5, 9
4. 3, 5, 9, 6, 7

---

- **다음 설명에 부합하는 용어로 옳은 것은?**
    
    정답: 3번
    
    규모가 큰 것을 여러 개로 나눈 조각,
    
    소프트웨어 구조를 이루는 기본적인 단위
    
    모듈이 되기 위한 특징
    
    - 다른 것들과 구별될 수 있는 독립적인 기능을 갖는 단위.
    - 유니크한 이름을 가짐
    - 모듈에서 또 다른 모듈을 호출 가능
    - 다른 프로그램에서도 모듈을 호출할 수 있다.
    
    데이터
    
    관찰하고 측정해서 얻은 Value
    
    저장소
    
    데이터를 논리적 구조로 조직화, 혹은 물리적 공간에 구축한것
    

- 소프트웨어 구조를 이루며, 다른 것들과 구별될 수 있는 독립적인 기을 갖는 단위이다.
- 하나 또는 몇 개의 논리적인 기능을 수행하기 위한 명령어들의 집합이라고도 할 수 있다.
- 서로 모여 하나의 완전한 프로그램으로 만들어 질 수 있다.

1. 통합 프로그램
2. 저장소
3. 모듈
4. 데이터

---

- **테스트 드라이버(Test Driver)에 대한 설명으로 틀린 것은?**
    
    정답: 4번
    
    <문제 해설>1, 2, 3번은 테스트 드라이버에 대한 설명4번은 테스트 스텁에 대한 설명테스트 드라이버(Driver)- 테스트 대상 하위 모듈을 호출하고, 파라미터 전달, 모듈 테스트 수행 후의 결과 도출- 상향식 테스트에 사용됨테스트 스텁(Stub)- 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구- 하향식 테스트에 사용됨
    

1. 시험대상 모듈을 호출하는 간이 소프트웨어이다.
2. 필요에 따라 매개 변수를 전달하고 모듈을 수행한 후의 결과를 보여줄 수 있다.
3. 상향식 통합 테스트에서 사용된다.
4. 테스트 대상 모듈이 호출하는 하위 모듈의 역할을 한다.

---

- **다음 중 선형 구조로만 묶인 것은?**
    
    정답: 2번
    
    선형구조: 리스트, 스택, 큐, 덱
    
    비선형구조: 트리, 그래프
    
    파일구조: 순차파일, 색인파일, 직접파일
    

1. 스택, 트리
2. 큐, 데크
3. 큐, 그래프
4. 리스트, 그래프

---

- **다음 중 스택을 이용한 연산과 거리가 먼 것은?**
    
    정답: 1번
    
    선택 정렬은 큐를 이용해서 정렬한다.
    

1. 선택정렬
2. 재귀 호출
3. 후위표현(Post-fix expression)의 연산
4. 깊이우선탐색

---

- **제품 소프트웨어의 사용자 매뉴얼 작성절차로 (가)~(다)와 [보기]의 기호를 바르게 연결한 것은?**
    
    정답: 2번
    
    사용자 매뉴얼 준비 절차
    
    작성 지침 정의 -> 사용자 매뉴얼 구성 요소 정의 -> 구성 요소별 내용 작성 -> 사용자 매뉴얼 검토
    
    설치와 사용에 필요한 제반 절차 및 환경 등 전체 내용을 포함하는 매뉴얼을 작성해야 합니다.
    

작성 지침 정의 → 가 → 나 → 다 → 사용설명서

- ㄱ 사용 설명서 검토
- ㄴ 구성 요소별 내용 작성
- ㄷ 사용 설명서 구성 요소 정의

1. 가-ㄱ 나-ㄴ 다-ㄷ
2. 가-ㄷ 나-ㄴ 다-ㄱ
3. 가-ㄱ 나-ㄷ 다-ㄴ
4. 가-ㄷ 나-ㄱ 다-ㄴ

---

- **순서가 A, B, C, D로 정해진 입력 자료를 스택에 입력한 후 출력한 결과로 불가능한 것은?**
    
    정답: 4번
    
    1. A push - B push - C push - D push - D pop - C pop - B pop - A pop
    
    2. A push - B push - B pop - C push - C pop - D push - D pop - A pop
    
    3. A push - B push - C push - C pop - B pop - A pop - D push - D pop
    
    4. 스택의 환경에서 불가능한 출력 결과물
    

1. D, C, B, A
2. B, C, D, A
3. C, B, A, D
4. D, B, C, A

---

- **소프트웨어 품질 목표 중 하나 이상의 하드웨어 환경에서 운용되기 위해 쉽게 수정될 수 있는 시스템 능력을 의미하는 것은?**
    
    정답: 1번
    
    이식성(Portability): 다양한 하드웨어 환경에서도 운용 가능하도록 쉽게 수정될 수 있는 능력
    
    2. 효율성(Efficiency): 최소의 작업으로 요구되는 기능을 수행하는 정도
    
    3. 사용 용이성(Usability): 소프트웨어를 쉽게 사용할 수 있는 정도
    
    4. 정확성(Correctness): 사용자의 요구사항을 충족시키는 정도
    

1. Portability
2. Efficiency
3. Usability
4. Correctness

---

- 화이트박스 테스트 유형 맞춰보기
    
    **구문 커버리지** : 모든 명령문을 적어도 한 번 수행 (조건문 결과와 관계x)
    
    **결정 커버리지** : 결정 포인트 내 전체 조건식이 적어도 한 번은 참과 거짓의 결과를 수행 -> '전체 조건'
    
    **조건 커버리지** : 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과를 수행 -> '개별 조건'
    
    **조건/결정 커버리지** : 전체 조건 + 개별 조건
    
    **변경 조건/결정 커버리지** : 개별 조건식이 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킴
    
    다중 조건 커버리지 : 결정조건 내 개별 조건식의 모든 가능한 조합을 보장
    
    기본 경로 커버리지 : 수행가능한 모든 경로를 테스트
    
    제어 흐름 테스트 : 프로그램 제어구조를 그래프 형태로 나타내어 내부로직 테스트
    
    데이터 흐름 테스트 : 제어 흐름 그래프 + 데이터 사용현황 추가한 그래프를 통해 테스트
    

화이트박스 테스트 유형

구문 커버리지 : ?

결정 커버리지 : ?

조건 커버리지 : ?

조건/결정 커버리지 : ?

변경 조건/결정 커버리지 : ?

다중 조건 커버리지 : ?

기본 경로 커버리지 : ?

제어 흐름 테스트 : ?

데이터 흐름 테스트 : ?

---

## 3과목

- **다음 중 관계 대수와 관계 해석에 대한 설명으로 올바르지 않은 것은?**
    
    답: 2번
    
    select: σ
    
    project: π
    
    join: ▷◁
    
    division: ÷
    

① 관계 대수는 관계형 데이터베이스에서 원하는 정보와 그 정보를 어떻게 유도하는가를 기술한 대수적인 연산 체계이자 절차적 정형 언어이다.

② 관계 대수 연산자의 종류 중 일반 집합 연산자 기호는 U, ∩, ⋈, × 등이 있다.

③ 관계 해석은 프레디킷 해석(Predicate Calculus)에 기반한 언어이며 비절차적 언어(원하는 정보가 무엇이라는 것만 선언)이다.

④ 관계 해석 연산자 논리기호는 ∨, ∧, ⌝ 등이 있다.

---

- **다음 중 스키마(Schema) 에 대한 설명으로 올바르지 않은 것은?**
    
    
1. Schema는 데이터베이스의 구조, 제약조건 등의 정보를 담고 있는 기본적인 구조이다.
2. External Schema는 사용자나 개발자의 관점에서 필요로 하는 데이터베이스의 논리적 구조이다.
3. Conceptual Schema는 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법을 표현한다.
4. Internal Schema는 물리적 저장장치의 관점에서 보는 데이터베이스 구조이다.

---

## 4과목

- **다음 트리에 대한 중위 순회 운행 결과는?**
    
    정답: 4번
    
    전위: 중앙 노드 먼저 방문
    
    중위: 왼쪽 노드 방문 후 중앙 노드 방문
    
    후위: 하위 트리 노드 모드 방문 중앙 노드 방문
    

![Untitled](%F0%9F%97%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8E%E1%85%A5%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3%20537e7630861e45e085dd1abe16fa15b5/Untitled%201.png)

1. ABDCEF
2. ABCDEF
3. DBECFA
4. DBAECF

---

- 관계 데이터베이스에 있어서 관계 대수 연산이 아닌 것은?
    
    정답: 3번
    
    관계 대수 연산에는
    
    1. Select
    
    2. Project
    
    3. Join
    
    4. Division 이 있디.
    
    [해설작성자 : comcbt.com 이용자]
    
    관계대수 연산에는
    
    1. 일반 집합 연산자
    
    합집합
    
    교집합
    
    차집합
    
    카티션 프로덕트
    
    2. 순수 관계 연산자
    
    셀렉트
    
    프로젝트
    
    조인
    
    디비전
    

1. 디비전
2. 프로젝트
3. 조인
4. 포크

---

- **로킹 단위(Locking Granularity)에 대한 설명으로 옳은 것은?**
    
    
    정답: 1번
    
    <문제 해설>로킹 단위가 큼 -> 로크의 수가 적어짐 -> 병행성 수준 낮아짐, 병행 제어 기법 간단해짐로킹 단위가 작음 -> 로크의 수가 많아짐[해설작성자 : 싹싹이]로킹 (병행제어 기법의 종류 중 하나)-직렬화 기법-데이터베이스, 파일, 레코드 등은 로킹단위가 될 수 있음.-로킹 단위가 작아지면, 데이터 베이스 공유도 증가.-로킹 단위가 작아지면, 로킹 오버헤드 증가.-로킹 단위가 작아지면, 로크의 수 증가.-로킹 단위가 작아지면, 병행성 수준이 높아짐.-한꺼번에 로킹할 수 있는 객체의 크기를 로킹단위 라고 함.
    

1. 로킹 단위가 크면 병행성 수준이 낮아진다
2. 로킹 단위가 크면 병행 제어 기법이 복잡해진다.
3. 로킹 단위가 적으면 로크(lock)의 수가 적어진다.
4. 로킹은 파일 단위로 이루어지며, 레코드와 필드는 로킹 단위가 될 수 없다.

---

- **이전 단계의 정규형을 만족하면서 후보키를 통하지 않는 조인 종속(JD : Join Dependency) 제거해야 만족하는 정규형은?**
    
    정답: 3번
    
    1. 제 1 정규형 : 릴레이션에 속한 모든 속성의 도메인이 더는 분해되지 않는 원자값으로만 구성되어 있음
    
    2. 제 2 정규형 : 제 1 정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속 되어야 함
    
    3. 제 3 정규형 : 제 2 정규형에 속하고 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않을 시 속함
    
    4. 제 4 정규형 : 보이스/코드 정규형을 만족하며 함수 종속이 아닌 다치 종속 제거시 만족
    
    5. 제 5 정규형 : 제 4 정규형을 만족하며 후보키를 통하지 않는 조인 종속 제거해야 만족
    

1. 제3정규형
2. 제4정규형
3. 제5정규형
4. 제6정규형

---

- **어떤 릴레이션 R에서 X와 Y를 각각 R의 애트리뷰트 집합의 부분 집합이라고 할 경우 애트리뷰트 X의 값 각각에 대해 시간에 관계없이 항상 애트리뷰트 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수 종속이라고 한다. 이 함수 종속의 표기로 옳은 것은?**
    
    정답: 3번
    
    <문제 해설>
    
    함수적 종속이란 어떤 릴레이션 R이 있을때 X와 Y를 각각 속성의 부분집합이라고 가정해봅니다. 여기서 X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, Y는 X에 함수적 종속이라고 합니다. 이 경우 X를 결정자, Y를 종속자라고 합니다.
    

1. Y → X
2. Y ⊂ X
3. X → Y
4. X ⊂ Y

---

- **오류 제어에 사용되는 자동반복 요청방식(ARQ)이 아닌 것은?**
    
    정답: 4번
    
    - Stop-and-Wait ARQ(정지-대기 ARQ): 송신 측이 하나의 블록을 전송한 후 수신 측에서 에러의 발생을 점검한 다음, 에러 발생 유무 신호를 보내올 때까지 기다리는 방식
    - Go-Back-N ARQ: 여러 블록을 연속적으로 전송하고, 수신 측에서 부정 응답(NAK)을 보내오면 송신 측이 오류가 발생한 블록부터 모두 재 전송
    - Selective-Reapeat ARQ(선택적 재전송 ARQ): 여러 블록을 연속적으로 전송하고, 수신측에서 부정 응답(NAK)을 보내오면 송신 측이 오류가 발생한 블록만을 재전송
    - Adaptive ARQ(적응적 ARQ): 전송 효율을 최대로 하기 위해서 데이터 블록의 길이를 채널의 상태에 따라 동적으로 변경하는 방식

1. Stop-and-wait ARQ
2. Go-back-N ARQ
3. Select-Repeat ARQ
4. Non-Acknowledge ARQ

---

- **사용자가 요청한 디스크 입·출력 내용이 다음과 같은 순서로 큐에 들어 있을 때 SSTF 스케쥴링을 사용한 경우의 처리 순서는? (단, 현재 헤드 위치는 53 이고, 제일 안쪽이 1번, 바깥쪽이 200번 트랙이다.)**
    
    정답: 1번
    
    <문제 해설>SSTF : shortest seek time first현재 헤드위치에서 가장 가까운 것부터..현재 헤드위치가 53이므로 65가 가장 가깝고( 차이 12) 다른것도 동일한 방법으로 해결.[해설작성자 : 귀살대]가장 가까운 것 => 가장 이동 거리가 짧은 것 => 현재 트랙과 남아있는 트랙 중 차이가 적은 것  53 - 65 - 67 - 37 - 14 - 98 - 122 - 124 - 183   12   2    30   23   84   24    2     59
    

![Untitled](%F0%9F%97%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8E%E1%85%A5%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3%20537e7630861e45e085dd1abe16fa15b5/Untitled%202.png)

1. 53-65-67-37-14-98-122-124-183
2. 53-98-183-37-122-14-124-65-67
3. 53-37-14-65-67-98-122-124-183
4. 53-67-65-124-14-122-37-183-98

---

- **192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 4개의 Subnet으로 나누고 IP Subnet-zero를 적용했다. 이 때 Subnetting 된 네트워크 중 4번째 네트워크의 4번째 사용가능한 IP는 무엇인가?**
    
    정답: 3번
    
    CIDR 표기법으로 ipv4 32비트중 앞 24비트가 네트워크ip, 뒤 8비트가 호스트ip가 됩니다.
    
    여기서 4개의 서브넷으로 나누려면 호스트ip의 앞쪽 비트를 가능한 적게 4개까지 나누어줘야 하는데요
    
    2진수에서 4개로 나누려면 2비트를 사용해야 하므로
    
    192.168.1.(00)000000 (0)
    
    192.168.1.(01)000000 (64)
    
    192.168.1.(10)000000 (128)
    
    192.168.1.(11)000000 (192)
    
    로 나눌 수 있습니다.
    
    여기서 IP subnet-zero를 적용했다는것은
    
    호스트ip가 전부 0인 192.168.1.0 도 사용하겠단것을 의미 합니다.
    
    즉 4번째 네트워크는 192.168.1.192가 되겠죠?
    
    단 각 서브넷에서 호스트ip가 전부 0인 주소와 전부 1인 주소는 다른 용도로 이미 예약이 되어있습니다.(0은 네트워크 자체의 주소, 1은 브로드캐스팅 주소)
    
    즉 여기서 4번째 사용가능한 ip는
    
    193,194,195,196←이게 되는거죠
    

1. 192.168.1.192
2. 192.168.1.195
3. 192.168.1.196
4. 192.168.1.198

---

- C Class에 속하는 IP Address는?
    
    정답: 1번
    
    <문제 해설>
    
    A class에 속하는 ip 주소 범위: 0.0.0.0 ~ 127.255.255.255
    
    B class에 속하는 ip 주소 범위: 128.0.0.0 ~ 191.255.255.255
    
    C class에 속하는 ip 주소 범위: 192.0.0.0 ~ 223.255.255.255
    
    D class와 E class는 각각 멀티캐스트용, 연구용으로 사용됩니다.
    
    D class ip 주소 범위: 224.0.0.0 ~ 239.255.255.255
    
    E class ip 주소 범위: 240.0.0.0 ~ 255.255.255.255
    

1. 200.168.30.1
2. 10.3.2.1 4
3. 225.2.4.1
4. 172.16.98.3

---

- **다음 JAVA 프로그램이 실행되었을 때의 결과를 쓰시오.**
    
    정답: 3번
    

![Untitled](%F0%9F%97%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8E%E1%85%A5%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3%20537e7630861e45e085dd1abe16fa15b5/Untitled%203.png)

1. 13
2. 21
3. 34
4. 55

---

- **다음은 C언어 코드이다. 출력 결과로 올바른 것을 고르시오?**
    - **switch에서 a/2 조건이 중요한데요, a가 5이므로 5/2=2.5이지만, C언어에서는 정수/정수는 정수값이 나오게 되므로 소수점은 버림처리되어 2가 됩니다.**
    - **case 2로 들어가게 되고, s++이 실행되어 s는 1이 됩니다.**
    - **break;가 없으므로 case 3에 a += s;가 실행되는데요, a에 s만큼 더한다는 의미이므로 a는 6이 됩니다.**
    - **마지막에 a++이 되면서 a는 7이 됩니다.**

```jsx
#include <stdio.h>
void main( ){

   int a = 5;
   int s = 0;

   switch(a/2){
   case 2 : s++;
   case 3 : a += s;
   default : a++;
   }

   printf("%d %d", s, a);
}
```

1. 1 5
2. 15
3. 1 7
4. 17

---

- OSI와 7계층은 각각 무엇이며 특징은 무엇인가?
    
    
    **1. OSI 7 계층이란?**
    
    OSI 7 계층은 네트워크에서 통신이 일어나는 과정을 7단계로 나눈 것을 말한다.
    
    **1계층 - 물리계층(Physical Layer)**
    
    이 계층에서는 주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하게 된다.
    
    이 계층에서 사용되는 통신 단위는 비트이며 이것은 1과 0으로 나타내어지는, 즉 전기적으로 On, Off 상태라고 생각하면 된다.
    
    **2계층 - 데이터 링크계층(DataLink Layer)**
    
    물리계층을 통해 송수신되는 정보의 오류와 흐름을 관리하여 안전한 **정보의 전달을 수행**할 수 있도록 도와주는 역할을 한다.
    
    따라서 통신에서의 오류도 찾아주고 재전송도 하는 기능을 가지고 있는 것이다.
    
    이 계층에서는 **맥 주소를 가지고 통신**하게 된다.
    
    이 계층에서 전송되는 단위를 프레임이라고 하고, 대표적인 장비로는 **브리지, 스위치** 등이 있다.(여기서 MAC주소를 사용한다.)
    
    - > **브릿지나 스위치를 통해 맥주소를 가지고 물리계층에서 받은 정보를 전달함**.
    
    데이터 링크 계층(Data link layer)은 포인트 투 포인트(Point to Point) 간 신뢰성있는 전송을 보장하기 위한 계층으로
    
    CRC 기반의 오류 제어와 흐름 제어가 필요하다. 네트워크 위의 개체들 간 데이터를 전달하고,
    
    물리 계층에서 발생할 수 있는 오류를 찾아 내고, 수정하는 데 필요한 기능적, 절차적 수단을 제공한다.
    
    주소 값은 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다.
    
    주소 체계는 계층이 없는 단일 구조이다. 데이터 링크 계층의 가장 잘 알려진 예는 이더넷이다.
    
    이 외에도 HDLC나 ADCCP 같은 포인트 투 포인트(point-to-point) 프로토콜이나
    
    패킷 스위칭 네트워크나 LLC, ALOHA 같은 근거리 네트워크용 프로토콜이 있다.
    
    네트워크 브릿지나 스위치 등이 이 계층에서 동작하며, 직접 이어진 곳에만 연결할 수 있다.
    
    **3계층 - 네트워크 계층(Network Layer)**
    
    이 계층에서 가장 중요한 기능은 **데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능(라우팅)**이다.
    
    여기에 사용되는 프로토콜의 종류도 다양하고, 라우팅하는 기술도 다양하다.
    
    이 계층은 경로를 선택하고 주소를 정하고 경로에 따라 패킷을 전달해주는 것이 이 계층의 역할이다.
    
    이 계층의 대표적인 장비는 라우터 이며, 요즘은 2계층의 장비 중 스위치라는 장비에 라우팅 기능을 장착한 Layer 3 스위치도 있다.
    
    (여기서 IP주소를 사용한다.)
    
    네트워크 계층(Network layer)은 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층으로
    
    다양한 길이의 데이터를 네트워크들을 통해 전달하고, 그 과정에서 전송 계층이 요구하는 서비스 품질(QoS)을 제공하기 위한
    
    기능적, 절차적 수단을 제공한다.
    
    네트워크 계층은 라우팅, 흐름 제어, 세그멘테이션(segmentation/desegmentation), 오류 제어, 인터네트워킹(Internetworking) 등을 수행한다.
    
    라우터가 이 계층에서 동작하고 이 계층에서 동작하는 스위치도 있다.
    
    데이터를 연결하는 다른 네트워크를 통해 전달함으로써 인터넷이 가능하게 만드는 계층이다.
    
    논리적인 주소 구조(IP), 곧 네트워크 관리자가 직접 주소를 할당하는 구조를 가지며, 계층적(hierarchical)이다.
    
    서브네트의 최상위 계층으로 경로를 설정하고, 청구 정보를 관리한다. 개방형 시스템들의 사이에서 네트워크 연결을 설정, 유지, 해제하는 기능을 부여하고, 전송 계층 사이에 네트워크 서비스 데이터 유닛(NSDU : Network Service Data Unit)을 교환하는 기능을 제공한다.
    
    - > **주소부여(IP), 경로설정(Route)**
        
        **2.3.1**
        
        **IP계층**
        
        TCP/IP 상에서 IP 계층이란 네트워크의 주소 (IP 주소)를 정의하고,
        
        **IP 패킷의 전달 및 라우팅을 담당하는 계층**
        
        2.3.2
        
        **IP 프로토콜**
        
        TCP/IP 기반의 인터넷 망을 통하여 데이타그램의 전달을 담당하는 프로토콜
        
        1. 주요 기능
        
        IP 계층에서 IP 패킷의 라우팅 대상이 됨 (Routing)
        
        IP 주소 지정 (Addressing)
        
        2. 주요 특징
        
        - `신뢰성(에러제어)` 및 `흐름제어` 기능이 전혀 없음 ☞ Best-Effort Service
        
        - 한편, 신뢰성을 확보하려면 IP 계층 위의 TCP와 같은 상위 트랜스포트 계층에 의존
        
        - 비연결성 데이터그램 방식으로 전달되는 프로토콜 ☞ Connectionles
    
    **4계층 - 전송 계층(Transport Layer)**
    
    통신을 활성화하기 위한 계층이다. 보통 TCP프로토콜을 이용하며, 포트를 열어서 응용프로그램들이 전송을 할 수 있게 한다.
    
    만약 데이터가 왔다면 4계층에서 해당 데이터를 하나로 합쳐서 5계층에 던져 준다.
    
    단대단 오류제어 및 흐름제어 이 계층 까지는 물리적인 계층에 속한다.(TCP/UDP프로토콜을 사용한다.)
    
    전송 계층(Transport layer)은 양 끝단(End to end)의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 해 주어,
    
    상위 계층들이 데이터 전달의 유효성이나 효율성을 생각하지 않도록 해준다.
    
    시퀀스 넘버 기반의 오류 제어 방식을 사용한다.
    
    전송 계층은 특정 연결의 유효성을 제어하고, 일부 프로토콜은 상태 개념이 있고(stateful),
    
    **연결 기반(connection oriented)**이다.
    
    이는 **전송 계층이 패킷들의 전송이 유효한지 확인하고 전송 실패한 패킷들을 다시 전송한다는 것**을 뜻한다.
    
    가장 잘 알려진 전송 계층의 예는 TCP이다.
    
    **2.4.1**
    
    **TCP 프로토콜(Transmission Control Protocol)**
    
    **UDP 프로토콜(User Datagram Protocol)**
    
    **5계층 -세션 계층(Session Layer)** 
    
    **데이터가 통신하기 위한 논리적인 연결**을 말한다. 통신을 하기위한 대문이라고 보면 된다.
    
    하지만 4계층에서도 연결을 맺고 종료할 수 있기 때문에 우리가 어느 계층에서 통신이 끊어 졌나 판단하기는 한계가 있다.
    
    그러므로 세션 계층은 4 계층과 무관하게 응용 프로그램 관점에서 봐야 한다.
    
    세션 설정, 유지, 종료, 전송 중단시 복구 등의 기능이 있다.
    
    세션 계층(Session layer)은 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다.
    
    **동시 송수신 방식(duplex), 반이중 방식(half-duplex), 전이중 방식(Full Duplex)**의 통신과 함께, 체크 포인팅과 유휴, 종료, 다시 시작 과정 등을 수행한다.
    
    이 계층은 **TCP/IP 세션을 만들고 없애는 책임**을 진다.
    
    **6계층 - 표현 계층(Presentation Layer)**
    
    데이터 표현이 상이한 응용 프로세스의 독립성을 제공하고, 암호화 한다.
    
    표현 계층(Presentation layer)은 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다. MIME 인코딩이나 암호화 등의 동작이 이 계층에서 이루어진다.
    
    **7계층 - 응용 계층(Application Layer)**
    
    최종 목적지로서 HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜이 있다.
    
    해당 통신 패킷들은 방금 나열한 프로토콜에 의해 모두 처리되며 우리가 사용하는 브라우저나, 메일 프로그램은 프로토콜을
    
    보다 쉽게 사용하게 해주는 응용프로그램이다. 한마디로 모든 통신의 양 끝단은 HTTP와 같은 프로토콜이지 응용프로그램이 아니다.
    

---

## 5과목: 정보시스템 구축관리

- 다음 내용이 설명하는 접근 제어 모델은?
    
    정답: 3번
    
    BLP 기밀성 모델: 정보의 불법적인 파괴나 변조보다는 불법적인 비밀 유출 방지에 중점 - 기밀성 강조
    
    Clark-Wilson 무결성 모델: 비밀 노출 방지보다 자료의 변조 방지가 더 중요함(금융, 회계관련 데이터, 기업 재무재표 등)
    
    Chinese Wall: 충돌을 야기시키는 어떠한 정보의 흐름도 없어야 한다. 이익의 충돌 금지, 최근 일을 한 적 있는 파트너는 동일 영역에 있는 다른 회사 자료에 접근해서는 안된다.
    

![Untitled](%F0%9F%97%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8E%E1%85%A5%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3%20537e7630861e45e085dd1abe16fa15b5/Untitled%204.png)

1. Clark-wilson Integrity Model
2. PDCA Model
3. Bell-lapadual Model
4. Chinese Wall Model

---

- **하둡(Hadoop)과 관계형 데이터베이스간에 데이터를 전송할 수 있도록 설계된 도구는?**
    
    정답: 3번
    
    스쿱: 커넥터를 사용하여 관계형 디비시스템(RDBMS)에서 HDFS로 데이터를 수집하는 빅데이터 기술
    

1. Apnic
2. Topology
3. Sqoop
4. SDB

---

- **라우팅 프로토콜인 OSPF(Open Shortest Path First)에 대한 설명으로 옳지 않은 것은?**
    
    정답: 2번
    
    거리 벡터 라우팅 프로토콜은 RIP
    
    OSPF 는 '링크 상태 알고리즘'을 사용합니다.
    

1. 네트워크 변화에 신속하게 대처할 수 있다.
2. 거리 벡터 라우팅 프로토콜이라고 한다.
3. 멀티캐스팅을 지웑한다.
4. 최단 경로 탐색에 Dijkstra 알고리즘을 사용한다

---

- **소프트웨어 비용 추정 모형(estimation models)이 아닌 것은?**
    
    정답: 4번
    
    - COCOMO : 시스템의 비용을 산정하기 위해 시스템을 구성하고 있는 모듈과 서브 시스템의 비용 합계를 계산하는 방식
    - Putnam : 소프트웨어 개발 주기의 간 단계별로 요구할 인력의 분포를 가정하는 모형
    - Function-Point(FP) : 요구 기능을 증가시키는 인자별로 가중치를 부여하여 기능의 점수를 계산하여 비용을 산정하는 방식
    - PERT : 계획 평가 및 재검토 기술, 프로젝트 관리를 분석하거나 주어진 완성 프로젝트를 포함한 일을 묘사하는데 쓰이는 모델

1. COCOMO
2. Putnam
3. Function-Poinmt
4. PERT

---

- **코드의 기입 과정에서 원래 '12536‘으로 기입되어야 하는데 ’12936‘으로 표기되었을 경우, 어떤 코드 오류에 해당하는가?**
    
    정답: 4번
    
    - 생략 오류(omission error)
    
    입력 시 한 자리를 빼놓고 기록한 경우
    
    (1234 → 123)
    
    - 필사 오류(Transcription error)
    
    입력 시 임의의 한 자리를 잘못 기록한 경우
    
    (1234 → 1235)
    
    - 전위 오류(Transposition error)
    
    입력 시 좌우 자리를 바꾸어 기록한 경우
    
    (1234 → 1243)
    
    - 이중 오류(Double Transposition error)
    
    전위 오류가 두 가지 이상 발생한 경우
    
    (1234 → 2143)
    
    - 추가 오류(Addition error)
    
    입력 시 한 자리 추가로 기록한 경우
    
    (1234 → 12345)
    
    - 임의 오류(Random error)
    
    위의 오류가 두 가지 이상 결합하여 발생한 경우
    
    (1234 → 12367)
    

1. Addtion Error
2. Omission Error
3. Sequence Error
4. Transcription Error

---

- **ISO 12207 표준의 기본 생명주기의 주요 프로세스에 해당하지 않는 것은?**
    
    정답: 4번
    소프트웨어의 생명 주기 동안 필요한 소프트웨어 제품의 획득, 공급, 개발, 운영, 유지보수 등으로 구성된다.
    

1. 획득 프로세스
2. 개발 프로세스
3. 성능평가 프로세스
4. 유지보수 프로세스

---

- **SPICE 모델의 프로세스 수행능력 수준의 단계별 설명이 틀린 것은?**
    
    SPICE 모델은
    
    수준 0부터 수준 5까지 총 6개의 수준이다.
    
    [해설작성자 : 해군본부 정체단 674기 수뱅]
    
    0단계 불안정 (구현 전 or 목적 달성 전)
    
    1단계 수행 (목적이 전반적으로 이뤄짐)
    
    2단계 관리 (작업 산출물 인도)
    
    3단계 확립(공학 원칙을 지킴)
    
    4단계 예측(산출물의 양적 측정이 가능해져, 일관된 수행 가능)
    
    5단계 최적화(지속적으로 업무 목적 만족)
    

1. 수준 8 - 미완성 단계
2. 수준 5- 최적화 단계
3. 수준 4- 예측 단계
4. 수준 3- 확립 단계

---

- 해쉬(Hash)기법에 대한 설명으로 틀린 것은?
    
    정답: 2번
    
    ＜암호화 방식＞
    
    1. 단방향
    
    1-1. 해시
    
    종류 :
    
    SHA, MD5, N-NASH, SNEFRU 등
    
    특징 :
    
    임의의 길이의 입력 데이터나 메시지를  고정 길이의 값이나 키로 변환
    
    암호화, 무결성 검증을 위하여 사용
    
    - --------------
    
    2. 양방향
    
    2-1. 개인키 (암호화, 복호화 시 동일한 개인키를 이용)
    
    종류 : Stream 방식 (평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화) : LFSR, RC4
    
    Block 방식 (한 번에 하나의 데이터 블록을 암호화) : DES, SEED, AES, ARIA
    
    특징 : 암호화/복호화 속도가 빠르며, 알고리즘이 단순, 공개키 암호 기법보다 파일 크기가 작음
    
    사용자의 증가에 따라 관리해야 할 키의 수가 상대적으로 많아진다
    
    2-2. 공개키 (암호화 시 사용자에게 공개되는 공개키 사용, 복호화 시 비밀키 사용, 비대칭 암호 기법이라고도 함)
    
    종류 : RSA
    
    특징 : 키의 분배가 용이하고, 관리해야 할 키 수가 적음
    
    암호화/복호화 속도가 느리며 알고리즘이 복잡, 개인키 암호화 방법보다 파일의 크기가 크다.
    

1. 임의의 길의의 입력 데이터를 받아 고정된 길이의 해쉬 값으로 변환한다
2. 주로 공개키 암호화 방식에서 키 생성을 위해 사용한다.
3. 대표적인 해쉬 알고리즘으로 HaVAL, SHA-1 이 있다.
4. 해쉬 함수는 일방향 함수(One-Way funciton)이다.

---

- **IPSec(IP Security)에 대한 설명으로 틀린 것은?**
    
    일방향 암호화는 해시암호화
    
    IPSec : IP계층(3계층)에서 무결성과 인증 보장하는 인증헤더와 기밀성 보장하는 암호화 이용해 양 종단 구간에 보안 서비스 ㅈ공하는 터널링 프로토콜
    
    - IPSec의 세부프로토콜
    - IKE(Internet Key Exchange) : 보안 관련 설정들을 생성, 협상 및 관리하는 프로토콜(udp500번 포트 사용)
    - ESP(Encapsulating Security Payload) : 메세지 인증코드,암호화 이용해 "인증(무결성)","발신지인증","기밀성" 제공 프로토콜
    - AH(Authentication Header) : 기밀성 제외한 메시지 인증코드 이용한 "인증(무결성)","발신지인증"제공 프로토콜

1. 암호화 수행시 일방향 암호화만 지원한다
2. ESP는 발신지 인증, 데이터 무결성, 기밀성 모두를 보장한다
3. 운영 모드는 Tunel 모드와 Transport 모드로 분류된다.
4. AH는 발신지 호스트를 인증하고, IP 패킷의 무결성을 보증한다.

---

- 메모리상에서 프로그램 복귀 주소와 변수 사이에 특정 값을 저장해두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?
    
    정답: 1번
    
    ASLR(Address Space Layout Randomization): 프로그램을 실행할 때마다 스택, 힙, 공유 라이브러리 등을 메모리에 적재할 때 주소를 랜덤화시키는 기법으로써, 공격자로 하여금 메모리 상의 주소를 추측하기 어렵게 한다.
    

1. Stack Guard
2. birdge
3. ASLR
4. FIN

---

- 침입차단 시스템(박화벽) 중 다음과 같은 형태의 구축 유형은?
    
    정답: 3번
    
    스크린 서브넷(Screen Subnet) : 외부 네트워크와 내부 네트워크 사이에 두는 완충적인 통신망
    

![Untitled](%F0%9F%97%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8E%E1%85%A5%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3%20537e7630861e45e085dd1abe16fa15b5/Untitled%205.png)

1. Block Host
2. Tree Host
3. Screened Subnet
4. Ring Homed

---

- **Secure OS의 보안 기능으로 거리가 먼 것은?**
    
    정답: 3번
    

1. 식별 및 인증
2. 임의적 접근 통제
3. 고가용성 지원
4. 강제적 접근 통제

---

- 서버에 열린 포트 정보를 스캐닝해서 보안취약점을 찾는데 사용하는 도구는?
    
    정답: 4번
    
    type : 말 그대로 type
    
    mkdir : 디렉토리 생성하는 명령어
    
    ftp : 응용계층 프로토콜
    

1. type
2. mkdir
3. ftp
4. nmap

---

- 프로세스와 관련된 설명으로 틀린 것은?
    
    정답: 4번
    
    <문제 해설>
    
    - 디스패치 (Dispatch) : 준비 -> 실행할당시간초과 (Time Run Out) : 실행 -> 준비대기 (Block) : 실행 -> 대기깨움 (Wake Up) : 대기 -> 준비PCB : 운영체제가 그 프로세스를 관리하는데 필요한 모든 정보를 유지하는 자료구조 테이블상태, 소유자, 실시간 통계, 스레드, 관련 프로세스 리스트, 자식 프로세스 리스트, 주소공간, 자원, 스택문맥교환 : CPU가 현재 실행하고 있는 프로세스의 상태를 PCB에 저장하고 다음 프로세스의 PCB로부터 문맥을 복원하는 작업프로세스의 실행단위를 스레드라고 불린다

1. 프로세스가 준비 상태에서 프로세서가 배당되어 실행 상태로 변화하는 것을 디스패치(Dispatch)라고 한다.
2. 프로세스 제어 블록(PCB, Process Control Block)은 프로세스 식별자, 프로세스 상태 등의 정보로 구성된다.
3. 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하는 과정을 문맥 교환(Context Switching)이라고 한다.
4. 프로세스는 스레드(Thread)내에서 실행되는 흐름의 단위이며, 스레드와 달리 주소 공간에 실행 스택(Stack)이 없다.

---

- 다음 중 페이지 교체(Page Replacement)알고리즘이 아닌 것은?
    
    정답: 2번
    
    <문제 해설>
    
    페이지 교체 알고리즘의 종류
    
    OPT - Optimal : 앞으로 가장 오랫동안 사용되지 않을 페이지 교체
    
    FIFO - First In First Out
    
    LRU - Least Recently Used : 가장 오랫동안 사용되지 않은 페이지 교체
    
    LFU - Least Frequently Used : 참조 횟수가 가장 작은 페이지 교체
    
    MFU - Most Frequently used : 참조 횟수가 가장 많은 페이지 교체
    
    NUR - Not Used Recently : 최근에 사용하지 않은 페이지 교체
    

1. FIFO(First-In-First-Out)
2. LUF(Least Used First)
3. Optimal
4. LRU(Least Recently Used)

---

- **침입탐지 시스템(IDS : Intrusion Detection System)과 관련한 설명으로 틀린 것은?**
    
    정답: 1번
    
    이상탐지(Anomaly Detection) -> Behavior, Statistical Detection로 불리며 평균적 시스템의 상태 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌
    
    오용탐지(Misuse Detection) -> Signature Base나 Knowledge Base로 불리며 미리 입력해둔 공격 패턴이 감지되면 이를 알려줌
    

1. 이상 탐지 기법(Anomaly Detection)은 Signature Base나 Knowledge Base라고도 불리며 이미 발견되고 정립된 공격 패턴을 입력해두었다가 탐지 및 차단한다.
2. HIDS(Host-Based Intrusion Detection)는 운영체제에 설정된 사용자 계정에 따라 어떤 사용자가 어떤 접근을 시도하고 어떤 작업을 했는지에 대한 기록을 남기고 추적한다.
3. NIDS(Network-Based Intrusion Detection System)로는 대표적으로 Snort가 있다.
4. 외부 인터넷에 서비스를 제공하는 서버가 위치하는 네트워크인 DMZ(Demilitarized Zone)에는 IDS가 설치될 수 있다.

---

- **정보 시스템 내에서 어떤 주체가 특정 개체에 접근하려 할 때 양쪽의 보안 레이블(Security Label)에 기초하여 높은 보안 수준을 요구하는 정보(객체)가 낮은 보안 수준의 주체에게 노출되지 않도록 하는 접근 제어 방법은?**
    
    정답: 1번
    
    강제접근통제(Mandatory Access Control), 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
    
    임의접근통제(Discretionary Access Control), 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
    
    사용자계정컨트롤(User Access Control), 프로그램에서 관리자 수준의 권한이 필요한 작업을 수행할 때 사용자에게 알려서 제어할 수 있도록 돕는 기능
    
    자료별 접근통제(Data-Label Access Control > Label-Based Access Control), 개별 행, 열에 대해 쓰기 권한, 읽기 권한을 가졌는지를 명확하게 결정하는 제어 방식
    

1. Mandatory Access Control
2. User Access Control
3. Discretionary Access Control
4. Data-Label Access Control

---

- **국내 IT 서비스 경쟁력 강화를 목표로 개발되었으며 인프라 제어 및 관리 환경, 실행 환경, 개발 환경, 서비스 환경, 운영환경으로 구성되어 있는 개방형 클라우드 컴퓨팅 플랫폼은?**
    
    정답: 2번
    
    PaaS-TA는 한국지능정보사회진흥원(NIA)가 지원하는 개방형 클라우드 플랫폼입니다.오픈 소스 기반의 Platform as a Service로서 Paas-TA의 "TA"는 "PaaS에 올라 타."의 의미라 합니다. 2016년 4월 버전 1.0 스파게티가 공개되었고, 2021년 2월 5.5 버전 세미나가 출시되어 차세대 전자정부 클라우드에 적용되어 전자정부 서비스의 표준 개발, 운영환경을 제공하는 역할을 수행할 예정이라 합니다.
    

1. N20S
2. PaaS-TA
3. KAWS
4. Metaverse

---

- **물리적 배치와 상관없이 논리적으로 LAN을 구성하여 Broadcast Domain을 구분할 수있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과가 있는 것은?**
    
    정답: 1번
    
    <문제 해설>VLAN(Virtual Local Area Network): 물리적 배치와 상관없이 논리적으로 LAN을 구성Broadcast Domain을 구분할 수 있게 해주는 기술로 접속된 장비들의 성능향상 및 보안성 증대 효과STP(Spanning Tree Protocol): 2개 이상의 스위치가 여러 경로로 연결될 때,무한 루프 현상을 막기 위해서 우선순위 따라 1개의 경로로만 통신하도록 하는 프로토콜ARP(Address Resolution Protocol): 네트워크 상에서 IP 주소를 물리적 네트워크 주소로 대응(bind)시키기 위해 사용되는 프로토콜,(IP를 MAC주소로 바인딩)
    

1. VLAN
2. STP
3. L2AN
4. ARP

---

- **비대칭 암호화 방식으로 소수를 활용한 암호화 알고리즘은?**
    
    정답: 4번
    
    <문제 해설>
    
    개인키 암호화 - 블록 암호화 방식 : DES, SEED, AES, ARIA
    
    개인키 암호화 - 스트림 암호화 방식 : LFSR, RC4
    
    공개키 암호화(비대칭 암호) : RSA
    

1. DES
2. AES
3. SMT
4. RSA

---

- **다음에서 설명하는 IT 스토리지 기술은?**
    
    정답: 1번
    
    두번째 단락의 '컴퓨팅 소프트웨어로(Software) 규정하는(Defined) 데이터 스토리지 체계이며,'
    
    => Software Defined Storage
    

![Untitled](%F0%9F%97%82%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8E%E1%85%A5%E1%84%80%E1%85%B5%20%E1%84%8B%E1%85%A9%E1%84%83%E1%85%A1%E1%86%B8%E1%84%82%E1%85%A9%E1%84%90%E1%85%B3%20537e7630861e45e085dd1abe16fa15b5/Untitled%206.png)

1. Software Defined Storage
2. Distribution Oriented Storage
3. Network Architected Storage
4. Systematic Network Storage

---

- **Cocomo model 중 기관 내부에서 개발된 중소규모의 소프트웨어로 일괄 자료 처리나 과학기술계산용, 비즈니스 자료 처리용으로 5만 라인이하의 소프트웨어를 개발하는 유형은?**
    
    정답: 2번
    
    Organic: 5만 라인 이하의 프로젝트에 적합, 소규모 팀이 개발에 사용
    
    Semidetached: 30만 라인 이하의 프로젝트에 적합, 트랜잭션 처리시스템 등
    
    Embeded: 30만 라인 이상의 프로젝트에 적합, 하드웨어가 포함된 실스간 시스템 등
    

1. Embeded
2. Organic
3. Semi-detached
4. Semi-embeded

---

- **소프트웨어 생명주기 모형 중 Spiral Model에 대한 설명으로 틀린 것은?**
    
    정답: 4번
    
    <문제 해설>
    
    spiral model = 나선형 모형, 점진적 모형1. 대규모2. 개발순서= 계획및 정의 - 위험 분석 - 공학적 개발 - 고객 평가3. sw개발하면서 발생할 수 있는 위험 관리 및 최소화 목적1&2&3의 경우 spiral model의 올바른 특징4. 여러번의 개발 과정을 거쳐 점진적으로 개발과정이 반복되므로 누락되거나 추가된 요구사항 첨가가능. 한번만 수행 x
    

1. 비교적 대규모 시스템에 적합하다
2. 개발 순서는 계획 및 정의, 위험 분석, 공학적 개발, 고객 평가 순으로 진행된다.
3. 소프트웨어를 개발하면서 발생할 수 있는 위험을 관리하고 최소화하는 것을 목적으로 한다.
4. 계획, 설계, 개발, 평가의 개발 주기가 한번만 수행된다.

---

- **TCP/IP 기반 네트워크에서 동작하는 발행-구독 기반의 메시징 프로토콜로 최근 IoT 환경에서 자주 사용되고 있는 프로토콜은?**
    
    정답: 2번
    
    MQTT 프로토콜
    
    - IBM 개발
    - 발행/구독 프로토콜
    - TCP/IP를 통해 실행되어 기본 네트워크 연결을 제공

1. MLFQ
2. MQTT
3. Zigbee
4. MTSP

---

- **시스템에 저장되는 패스워드들은 Hash 또는 암호화 알고리즘의 결과 값으로 저장된다. 이때 암호공격을 막기 위해 똑같은 패스워드들이 다른 암호 값으로 저장되도록 추가되는 값을 의미하는 것은?**
    
    정답: 4번
    
    Hash와 Encryption 차이
    
    - Hash : 단방향, 복호화 불가능
    - Encryption : 양방향, 역으로 복호화 가능
    
    패스워드는 보통 단방향 Hash를 기본으로 저장
    
    문제점
    
    같은 패스워드를 hashing하면 같은 결과값이 나타나게되고 이는 문제를 발생함
    
    해결법
    
    이를 위해 다른 암호 값으로 저장되도록 추가되는 값 = Salt
    
    의미 그대로 소금친다는 뜻에서 Salt라고 불림
    

1. Pass flag
2. Bucket
3. Opcode
4. Salt

---

- **S/W 각 기능의 원시 코드 라인수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법은?**
    
    정답: 4번
    
    1. Effort Per Task 기법 - (LOC기법을 보완하기위함)각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정
    
    2. 전문가 감정 기법 - 두 명이상의 전문가에게 비용 산정을 의뢰하는 기법, 개인적이고 주관적
    
    3. 델파이 기법 - (전문가감정 기법의 주관적인 편견 보완하기위함)한명의 조정자와 여러 전문가의 의견을 종합하여 산정하는 기법
    
    4. LOC기법 - 원시코드라인수(source line of code)의 비관치, 낙관치, 기대치를 측정 예측치 구함, 본문문제내용동일.
    
    cf. 2&3의 경우 - 하향식 비용 산정 기법이며 1&4의 경우 상향식 비용 산정 기법이다.
    

1. Effort Per Task기법
2. 전문가 감정 기법
3. 델파이기법
4. LOC기법

---

- **오픈소스 웹 애플리케이션 보안 프로젝트로서 주로 웹을 통한 정보 유출, 악성 파일 및 스크립트, 보안 취약점 등을 연구하는 곳은?**
    
    정답: 2번
    
    OWASP(The Open Web Application Security Project)는 오픈소스 웹 애플리케이션 보안 프로젝트이다. 주로 웹에 관한 정보노출, 악성 파일 및 스크립트, 보안 취약점 등을 연구함
    

1. WWW
2. OWASP
3. WBSEC
4. ITU

---

- **다음 중 고정된 기반 망의 도움 없이 이동 노드 간에 자율적으로 구성되는 망으로서, 네트워크에 자율성과 융통성을 부여한 네트워크로 Peer-to-Peer 통신, 다중 홉, 이동 노드 간 동적 네트워크를 구성할 수 있는 특징이 있는 네트워크는?**
    
    정답: 2번
    
    Wireless Body Area Network: 인체 통신망, 인체 영역 통신망, 보디 에어리어 네트워크, WBAN, MBAN은 착용식 컴퓨팅 장치의 무선 네트워크이다. BAN 장치들은 몸 안에 임플란트 방식으로 심어넣거나 고정 위치에 체외 표면 실장을 하거나, 옷 주머니, 손, 가방 등 사람이 여러 곳에 휴대할 수 있다.
    
    ad-hoc Network: 핸드폰처럼 기지국과 단말이 통신하는 형태가 아니라,각 단말끼리 연결이 되는 형태로 멀리 떨어져 있는 단말끼리는 중간에 있는 단말들이 중계기 역할을 해 주어서 통신을 하게 된다. 통신기기간 특별한 무선 통신을 '**Ad**-**hoc**  네트워킹'이라고 부른다.
    
    Mesh Network: 메시 네트워크는 각각의 노드가 네트워크에 대해 데이터를 릴레하는 네트워크 토폴로지이다. 모든 메시 노드들은 네트워크 내의 데이터 분산에 협업한다. 무선과 유선망에 모두 적용이 가능하다. 무선 메시 네트워크는 무선 애드혹 네트워크의 일종으로 간주할 수 있다.
    
    Wireless Smart Utility Network: **Wi-SUN은 최소의 추가 인프라로 밀집된 도시 지역에서 농촌 지역에 이르기까지 다양한 지형 환경에서 유비쿼터스 적용 범위와 함께 탄력 있고 안전하며 비용 효율적인 연결을 제공하기 위해 메시 지원 필드 영역 네트워크(FAN)를 제공합니다.**
    

① Wireless Body Area Network

② Ad-hoc Network

③ Mesh Network

④ Wireless Smart Utility Network

---

- 다음 중 소프트웨어 개발사의 네트워크에 침투하여 소스 코드의 수정 등을 통해 악의적인 코드를 삽입하는 방식으로 사용자 PC에 소프트웨어를 설치 또는 업데이트 시에 자동적으로 감염되도록 하는 공격은?
    
    정답: 2번
    
    Botmet: 악성 프로그램에 감염되어 악의적인 의도로 사용될 수 있는 다수의 컴퓨터들이 네트워크로 연결된 형태
    
    Ranwsomware:  개인과 기업, 국가적으로 큰 위협이 되고 있는 주요 사이버 범죄 중 하나로 Snake, Draside 등 시스템을 잠그거나 데이터를 암호화해 사용할 수 없도록 하고 이를 금전적으로 요구하는 데 사용되는 악성 프로그램
    
    Logic Bomb: 특정 날짜나 시간 등 조건이 충족되었을 때 악의적인 기능을 유발할 수 있게 만든 코드의 일부분으로 소프트웨어 시스템에 의도적으로 삽입된 코드
    
    APT Persistent Treat: 특정 타깃을 목표로 하여 다양한 수단을 통한 지속적이고 지능적인 맞춤형 공격 기법
    
    Supply Chain Attack: 소프트웨어 개발사의 네트워크에 침투하여 소스 코드의 수정 등을 통해 악의적인 코드를 삽입하거나 배포 서버에 접근하여 악의적인 파일로 변경하는 방식을 통해 사용자 피씨에 소프트웨어를 설치 또는 업데이트시에 자동적으로 감염되도록 하는 공격
    
    Trojan Horse: 악성 루틴이 숨어 있는 프로그램으로 겉보기에는 정상적인 프로그램으로 보이지만 실행하면 악성 코드를 실행
    
    Stuxnet: 스턱스넷(**Stuxnet**)은 2010년 6월에 발견된 웜 바이러스이다. 마이크로소프트 윈도우를 통해 감염되어, 지멘스 산업의 소프트웨어 및 장비를 공격한다. 이 웜이 산업시설을 공격하는 최초의 악성 소프트웨어는 아니지만, 산업시설을 감시하고 파괴하는 악성 소프트웨어로는 최초이다.
    
1. Logic Bomb
2. Supply Chain Attack
3. Ransomware
4. Stuxnet

---